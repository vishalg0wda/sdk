// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

// ForceNew - Forces a new deployment even if there is a previous similar deployment
type ForceNew string

const (
	ForceNewZero ForceNew = "0"
	ForceNewOne  ForceNew = "1"
)

func (e ForceNew) ToPointer() *ForceNew {
	return &e
}
func (e *ForceNew) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "0":
		fallthrough
	case "1":
		*e = ForceNew(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ForceNew: %v", v)
	}
}

// SkipAutoDetectionConfirmation - Allows to skip framework detection so the API would not fail to ask for confirmation
type SkipAutoDetectionConfirmation string

const (
	SkipAutoDetectionConfirmationZero SkipAutoDetectionConfirmation = "0"
	SkipAutoDetectionConfirmationOne  SkipAutoDetectionConfirmation = "1"
)

func (e SkipAutoDetectionConfirmation) ToPointer() *SkipAutoDetectionConfirmation {
	return &e
}
func (e *SkipAutoDetectionConfirmation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "0":
		fallthrough
	case "1":
		*e = SkipAutoDetectionConfirmation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SkipAutoDetectionConfirmation: %v", v)
	}
}

// UploadedFile - Used in the case you want to reference a file that was already uploaded
type UploadedFile struct {
	// The file path relative to the project root
	File string `json:"file"`
	// The file contents hashed with SHA1, used to check the integrity
	Sha *string `json:"sha,omitempty"`
	// The file size in bytes
	Size *int64 `json:"size,omitempty"`
}

func (o *UploadedFile) GetFile() string {
	if o == nil {
		return ""
	}
	return o.File
}

func (o *UploadedFile) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *UploadedFile) GetSize() *int64 {
	if o == nil {
		return nil
	}
	return o.Size
}

// Encoding - The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
type Encoding string

const (
	EncodingBase64 Encoding = "base64"
	EncodingUTF8   Encoding = "utf-8"
)

func (e Encoding) ToPointer() *Encoding {
	return &e
}
func (e *Encoding) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "base64":
		fallthrough
	case "utf-8":
		*e = Encoding(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Encoding: %v", v)
	}
}

// InlinedFile - Used in the case you want to inline a file inside the request
type InlinedFile struct {
	// The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code
	Data string `json:"data"`
	// The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
	Encoding *Encoding `json:"encoding,omitempty"`
	// The file name including the whole path
	File string `json:"file"`
}

func (o *InlinedFile) GetData() string {
	if o == nil {
		return ""
	}
	return o.Data
}

func (o *InlinedFile) GetEncoding() *Encoding {
	if o == nil {
		return nil
	}
	return o.Encoding
}

func (o *InlinedFile) GetFile() string {
	if o == nil {
		return ""
	}
	return o.File
}

type FilesType string

const (
	FilesTypeInlinedFile  FilesType = "InlinedFile"
	FilesTypeUploadedFile FilesType = "UploadedFile"
)

type Files struct {
	InlinedFile  *InlinedFile
	UploadedFile *UploadedFile

	Type FilesType
}

func CreateFilesInlinedFile(inlinedFile InlinedFile) Files {
	typ := FilesTypeInlinedFile

	return Files{
		InlinedFile: &inlinedFile,
		Type:        typ,
	}
}

func CreateFilesUploadedFile(uploadedFile UploadedFile) Files {
	typ := FilesTypeUploadedFile

	return Files{
		UploadedFile: &uploadedFile,
		Type:         typ,
	}
}

func (u *Files) UnmarshalJSON(data []byte) error {

	var inlinedFile InlinedFile = InlinedFile{}
	if err := utils.UnmarshalJSON(data, &inlinedFile, "", true, true); err == nil {
		u.InlinedFile = &inlinedFile
		u.Type = FilesTypeInlinedFile
		return nil
	}

	var uploadedFile UploadedFile = UploadedFile{}
	if err := utils.UnmarshalJSON(data, &uploadedFile, "", true, true); err == nil {
		u.UploadedFile = &uploadedFile
		u.Type = FilesTypeUploadedFile
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Files", string(data))
}

func (u Files) MarshalJSON() ([]byte, error) {
	if u.InlinedFile != nil {
		return utils.MarshalJSON(u.InlinedFile, "", true)
	}

	if u.UploadedFile != nil {
		return utils.MarshalJSON(u.UploadedFile, "", true)
	}

	return nil, errors.New("could not marshal union type Files: all fields are null")
}

// GitMetadata - Populates initial git metadata for different git providers.
type GitMetadata struct {
	// The git repository's remote origin url
	RemoteURL *string `json:"remoteUrl,omitempty"`
	// The name of the author of the commit
	CommitAuthorName *string `json:"commitAuthorName,omitempty"`
	// The commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// The branch on which the commit was made
	CommitRef *string `json:"commitRef,omitempty"`
	// The hash of the commit
	CommitSha *string `json:"commitSha,omitempty"`
	// Whether or not there have been modifications to the working tree since the latest commit
	Dirty *bool `json:"dirty,omitempty"`
}

func (o *GitMetadata) GetRemoteURL() *string {
	if o == nil {
		return nil
	}
	return o.RemoteURL
}

func (o *GitMetadata) GetCommitAuthorName() *string {
	if o == nil {
		return nil
	}
	return o.CommitAuthorName
}

func (o *GitMetadata) GetCommitMessage() *string {
	if o == nil {
		return nil
	}
	return o.CommitMessage
}

func (o *GitMetadata) GetCommitRef() *string {
	if o == nil {
		return nil
	}
	return o.CommitRef
}

func (o *GitMetadata) GetCommitSha() *string {
	if o == nil {
		return nil
	}
	return o.CommitSha
}

func (o *GitMetadata) GetDirty() *bool {
	if o == nil {
		return nil
	}
	return o.Dirty
}

type CreateDeploymentGitSourceDeploymentsRequestType string

const (
	CreateDeploymentGitSourceDeploymentsRequestTypeBitbucket CreateDeploymentGitSourceDeploymentsRequestType = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsRequestType) ToPointer() *CreateDeploymentGitSourceDeploymentsRequestType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsRequestType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsRequestType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsRequestType: %v", v)
	}
}

type Five struct {
	Owner string                                          `json:"owner"`
	Ref   string                                          `json:"ref"`
	Sha   *string                                         `json:"sha,omitempty"`
	Slug  string                                          `json:"slug"`
	Type  CreateDeploymentGitSourceDeploymentsRequestType `json:"type"`
}

func (o *Five) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *Five) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *Five) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *Five) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *Five) GetType() CreateDeploymentGitSourceDeploymentsRequestType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsRequestType("")
	}
	return o.Type
}

type CreateDeploymentGitSourceDeploymentsType string

const (
	CreateDeploymentGitSourceDeploymentsTypeBitbucket CreateDeploymentGitSourceDeploymentsType = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsType) ToPointer() *CreateDeploymentGitSourceDeploymentsType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsType: %v", v)
	}
}

type Four struct {
	Ref           string                                   `json:"ref"`
	RepoUUID      string                                   `json:"repoUuid"`
	Sha           *string                                  `json:"sha,omitempty"`
	Type          CreateDeploymentGitSourceDeploymentsType `json:"type"`
	WorkspaceUUID *string                                  `json:"workspaceUuid,omitempty"`
}

func (o *Four) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *Four) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *Four) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *Four) GetType() CreateDeploymentGitSourceDeploymentsType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsType("")
	}
	return o.Type
}

func (o *Four) GetWorkspaceUUID() *string {
	if o == nil {
		return nil
	}
	return o.WorkspaceUUID
}

type ProjectIDType string

const (
	ProjectIDTypeNumber ProjectIDType = "number"
	ProjectIDTypeStr    ProjectIDType = "str"
)

type ProjectID struct {
	Number *float64
	Str    *string

	Type ProjectIDType
}

func CreateProjectIDNumber(number float64) ProjectID {
	typ := ProjectIDTypeNumber

	return ProjectID{
		Number: &number,
		Type:   typ,
	}
}

func CreateProjectIDStr(str string) ProjectID {
	typ := ProjectIDTypeStr

	return ProjectID{
		Str:  &str,
		Type: typ,
	}
}

func (u *ProjectID) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = ProjectIDTypeNumber
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ProjectIDTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectID", string(data))
}

func (u ProjectID) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectID: all fields are null")
}

type CreateDeploymentGitSourceType string

const (
	CreateDeploymentGitSourceTypeGitlab CreateDeploymentGitSourceType = "gitlab"
)

func (e CreateDeploymentGitSourceType) ToPointer() *CreateDeploymentGitSourceType {
	return &e
}
func (e *CreateDeploymentGitSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = CreateDeploymentGitSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceType: %v", v)
	}
}

type Three struct {
	ProjectID ProjectID                     `json:"projectId"`
	Ref       string                        `json:"ref"`
	Sha       *string                       `json:"sha,omitempty"`
	Type      CreateDeploymentGitSourceType `json:"type"`
}

func (o *Three) GetProjectID() ProjectID {
	if o == nil {
		return ProjectID{}
	}
	return o.ProjectID
}

func (o *Three) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *Three) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *Three) GetType() CreateDeploymentGitSourceType {
	if o == nil {
		return CreateDeploymentGitSourceType("")
	}
	return o.Type
}

type GitSourceType string

const (
	GitSourceTypeGithub GitSourceType = "github"
)

func (e GitSourceType) ToPointer() *GitSourceType {
	return &e
}
func (e *GitSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = GitSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GitSourceType: %v", v)
	}
}

type Two struct {
	Org  string        `json:"org"`
	Ref  string        `json:"ref"`
	Repo string        `json:"repo"`
	Sha  *string       `json:"sha,omitempty"`
	Type GitSourceType `json:"type"`
}

func (o *Two) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *Two) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *Two) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *Two) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *Two) GetType() GitSourceType {
	if o == nil {
		return GitSourceType("")
	}
	return o.Type
}

type RepoIDType string

const (
	RepoIDTypeNumber RepoIDType = "number"
	RepoIDTypeStr    RepoIDType = "str"
)

type RepoID struct {
	Number *float64
	Str    *string

	Type RepoIDType
}

func CreateRepoIDNumber(number float64) RepoID {
	typ := RepoIDTypeNumber

	return RepoID{
		Number: &number,
		Type:   typ,
	}
}

func CreateRepoIDStr(str string) RepoID {
	typ := RepoIDTypeStr

	return RepoID{
		Str:  &str,
		Type: typ,
	}
}

func (u *RepoID) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = RepoIDTypeNumber
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = RepoIDTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RepoID", string(data))
}

func (u RepoID) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type RepoID: all fields are null")
}

type Type string

const (
	TypeGithub Type = "github"
)

func (e Type) ToPointer() *Type {
	return &e
}
func (e *Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Type: %v", v)
	}
}

type One struct {
	Ref    string  `json:"ref"`
	RepoID RepoID  `json:"repoId"`
	Sha    *string `json:"sha,omitempty"`
	Type   Type    `json:"type"`
}

func (o *One) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *One) GetRepoID() RepoID {
	if o == nil {
		return RepoID{}
	}
	return o.RepoID
}

func (o *One) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *One) GetType() Type {
	if o == nil {
		return Type("")
	}
	return o.Type
}

type GitSourceUnionType string

const (
	GitSourceUnionTypeOne   GitSourceUnionType = "1"
	GitSourceUnionTypeTwo   GitSourceUnionType = "2"
	GitSourceUnionTypeThree GitSourceUnionType = "3"
	GitSourceUnionTypeFour  GitSourceUnionType = "4"
	GitSourceUnionTypeFive  GitSourceUnionType = "5"
)

// GitSource - Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
type GitSource struct {
	One   *One
	Two   *Two
	Three *Three
	Four  *Four
	Five  *Five

	Type GitSourceUnionType
}

func CreateGitSourceOne(one One) GitSource {
	typ := GitSourceUnionTypeOne

	return GitSource{
		One:  &one,
		Type: typ,
	}
}

func CreateGitSourceTwo(two Two) GitSource {
	typ := GitSourceUnionTypeTwo

	return GitSource{
		Two:  &two,
		Type: typ,
	}
}

func CreateGitSourceThree(three Three) GitSource {
	typ := GitSourceUnionTypeThree

	return GitSource{
		Three: &three,
		Type:  typ,
	}
}

func CreateGitSourceFour(four Four) GitSource {
	typ := GitSourceUnionTypeFour

	return GitSource{
		Four: &four,
		Type: typ,
	}
}

func CreateGitSourceFive(five Five) GitSource {
	typ := GitSourceUnionTypeFive

	return GitSource{
		Five: &five,
		Type: typ,
	}
}

func (u *GitSource) UnmarshalJSON(data []byte) error {

	var one One = One{}
	if err := utils.UnmarshalJSON(data, &one, "", true, true); err == nil {
		u.One = &one
		u.Type = GitSourceUnionTypeOne
		return nil
	}

	var three Three = Three{}
	if err := utils.UnmarshalJSON(data, &three, "", true, true); err == nil {
		u.Three = &three
		u.Type = GitSourceUnionTypeThree
		return nil
	}

	var two Two = Two{}
	if err := utils.UnmarshalJSON(data, &two, "", true, true); err == nil {
		u.Two = &two
		u.Type = GitSourceUnionTypeTwo
		return nil
	}

	var four Four = Four{}
	if err := utils.UnmarshalJSON(data, &four, "", true, true); err == nil {
		u.Four = &four
		u.Type = GitSourceUnionTypeFour
		return nil
	}

	var five Five = Five{}
	if err := utils.UnmarshalJSON(data, &five, "", true, true); err == nil {
		u.Five = &five
		u.Type = GitSourceUnionTypeFive
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitSource", string(data))
}

func (u GitSource) MarshalJSON() ([]byte, error) {
	if u.One != nil {
		return utils.MarshalJSON(u.One, "", true)
	}

	if u.Two != nil {
		return utils.MarshalJSON(u.Two, "", true)
	}

	if u.Three != nil {
		return utils.MarshalJSON(u.Three, "", true)
	}

	if u.Four != nil {
		return utils.MarshalJSON(u.Four, "", true)
	}

	if u.Five != nil {
		return utils.MarshalJSON(u.Five, "", true)
	}

	return nil, errors.New("could not marshal union type GitSource: all fields are null")
}

// Framework - The framework that is being used for this project. When `null` is used no framework is selected
type Framework string

const (
	FrameworkBlitzjs        Framework = "blitzjs"
	FrameworkNextjs         Framework = "nextjs"
	FrameworkGatsby         Framework = "gatsby"
	FrameworkRemix          Framework = "remix"
	FrameworkAstro          Framework = "astro"
	FrameworkHexo           Framework = "hexo"
	FrameworkEleventy       Framework = "eleventy"
	FrameworkDocusaurus2    Framework = "docusaurus-2"
	FrameworkDocusaurus     Framework = "docusaurus"
	FrameworkPreact         Framework = "preact"
	FrameworkSolidstart1    Framework = "solidstart-1"
	FrameworkSolidstart     Framework = "solidstart"
	FrameworkDojo           Framework = "dojo"
	FrameworkEmber          Framework = "ember"
	FrameworkVue            Framework = "vue"
	FrameworkScully         Framework = "scully"
	FrameworkIonicAngular   Framework = "ionic-angular"
	FrameworkAngular        Framework = "angular"
	FrameworkPolymer        Framework = "polymer"
	FrameworkSvelte         Framework = "svelte"
	FrameworkSveltekit      Framework = "sveltekit"
	FrameworkSveltekit1     Framework = "sveltekit-1"
	FrameworkIonicReact     Framework = "ionic-react"
	FrameworkCreateReactApp Framework = "create-react-app"
	FrameworkGridsome       Framework = "gridsome"
	FrameworkUmijs          Framework = "umijs"
	FrameworkSapper         Framework = "sapper"
	FrameworkSaber          Framework = "saber"
	FrameworkStencil        Framework = "stencil"
	FrameworkNuxtjs         Framework = "nuxtjs"
	FrameworkRedwoodjs      Framework = "redwoodjs"
	FrameworkHugo           Framework = "hugo"
	FrameworkJekyll         Framework = "jekyll"
	FrameworkBrunch         Framework = "brunch"
	FrameworkMiddleman      Framework = "middleman"
	FrameworkZola           Framework = "zola"
	FrameworkHydrogen       Framework = "hydrogen"
	FrameworkVite           Framework = "vite"
	FrameworkVitepress      Framework = "vitepress"
	FrameworkVuepress       Framework = "vuepress"
	FrameworkParcel         Framework = "parcel"
	FrameworkFasthtml       Framework = "fasthtml"
	FrameworkSanityV3       Framework = "sanity-v3"
	FrameworkSanity         Framework = "sanity"
	FrameworkStorybook      Framework = "storybook"
)

func (e Framework) ToPointer() *Framework {
	return &e
}
func (e *Framework) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blitzjs":
		fallthrough
	case "nextjs":
		fallthrough
	case "gatsby":
		fallthrough
	case "remix":
		fallthrough
	case "astro":
		fallthrough
	case "hexo":
		fallthrough
	case "eleventy":
		fallthrough
	case "docusaurus-2":
		fallthrough
	case "docusaurus":
		fallthrough
	case "preact":
		fallthrough
	case "solidstart-1":
		fallthrough
	case "solidstart":
		fallthrough
	case "dojo":
		fallthrough
	case "ember":
		fallthrough
	case "vue":
		fallthrough
	case "scully":
		fallthrough
	case "ionic-angular":
		fallthrough
	case "angular":
		fallthrough
	case "polymer":
		fallthrough
	case "svelte":
		fallthrough
	case "sveltekit":
		fallthrough
	case "sveltekit-1":
		fallthrough
	case "ionic-react":
		fallthrough
	case "create-react-app":
		fallthrough
	case "gridsome":
		fallthrough
	case "umijs":
		fallthrough
	case "sapper":
		fallthrough
	case "saber":
		fallthrough
	case "stencil":
		fallthrough
	case "nuxtjs":
		fallthrough
	case "redwoodjs":
		fallthrough
	case "hugo":
		fallthrough
	case "jekyll":
		fallthrough
	case "brunch":
		fallthrough
	case "middleman":
		fallthrough
	case "zola":
		fallthrough
	case "hydrogen":
		fallthrough
	case "vite":
		fallthrough
	case "vitepress":
		fallthrough
	case "vuepress":
		fallthrough
	case "parcel":
		fallthrough
	case "fasthtml":
		fallthrough
	case "sanity-v3":
		fallthrough
	case "sanity":
		fallthrough
	case "storybook":
		*e = Framework(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Framework: %v", v)
	}
}

// NodeVersion - Override the Node.js version that should be used for this deployment
type NodeVersion string

const (
	NodeVersionTwentyTwoX NodeVersion = "22.x"
	NodeVersionTwentyX    NodeVersion = "20.x"
	NodeVersionEighteenX  NodeVersion = "18.x"
	NodeVersionSixteenX   NodeVersion = "16.x"
	NodeVersionFourteenX  NodeVersion = "14.x"
	NodeVersionTwelveX    NodeVersion = "12.x"
	NodeVersionTenX       NodeVersion = "10.x"
	NodeVersionEight10X   NodeVersion = "8.10.x"
)

func (e NodeVersion) ToPointer() *NodeVersion {
	return &e
}
func (e *NodeVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "22.x":
		fallthrough
	case "20.x":
		fallthrough
	case "18.x":
		fallthrough
	case "16.x":
		fallthrough
	case "14.x":
		fallthrough
	case "12.x":
		fallthrough
	case "10.x":
		fallthrough
	case "8.10.x":
		*e = NodeVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NodeVersion: %v", v)
	}
}

// ProjectSettings - Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
type ProjectSettings struct {
	// The build command for this project. When `null` is used this value will be automatically detected
	BuildCommand                *string `json:"buildCommand,omitempty"`
	CommandForIgnoringBuildStep *string `json:"commandForIgnoringBuildStep,omitempty"`
	// The dev command for this project. When `null` is used this value will be automatically detected
	DevCommand *string `json:"devCommand,omitempty"`
	// The framework that is being used for this project. When `null` is used no framework is selected
	Framework *Framework `json:"framework,omitempty"`
	// The install command for this project. When `null` is used this value will be automatically detected
	InstallCommand *string `json:"installCommand,omitempty"`
	// Override the Node.js version that should be used for this deployment
	NodeVersion *NodeVersion `json:"nodeVersion,omitempty"`
	// The output directory of the project. When `null` is used this value will be automatically detected
	OutputDirectory *string `json:"outputDirectory,omitempty"`
	// The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
	RootDirectory *string `json:"rootDirectory,omitempty"`
	// The region to deploy Serverless Functions in this project
	ServerlessFunctionRegion *string `json:"serverlessFunctionRegion,omitempty"`
	// Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	SkipGitConnectDuringLink *bool `json:"skipGitConnectDuringLink,omitempty"`
	// Indicates if there are source files outside of the root directory, typically used for monorepos
	SourceFilesOutsideRootDirectory *bool `json:"sourceFilesOutsideRootDirectory,omitempty"`
}

func (o *ProjectSettings) GetBuildCommand() *string {
	if o == nil {
		return nil
	}
	return o.BuildCommand
}

func (o *ProjectSettings) GetCommandForIgnoringBuildStep() *string {
	if o == nil {
		return nil
	}
	return o.CommandForIgnoringBuildStep
}

func (o *ProjectSettings) GetDevCommand() *string {
	if o == nil {
		return nil
	}
	return o.DevCommand
}

func (o *ProjectSettings) GetFramework() *Framework {
	if o == nil {
		return nil
	}
	return o.Framework
}

func (o *ProjectSettings) GetInstallCommand() *string {
	if o == nil {
		return nil
	}
	return o.InstallCommand
}

func (o *ProjectSettings) GetNodeVersion() *NodeVersion {
	if o == nil {
		return nil
	}
	return o.NodeVersion
}

func (o *ProjectSettings) GetOutputDirectory() *string {
	if o == nil {
		return nil
	}
	return o.OutputDirectory
}

func (o *ProjectSettings) GetRootDirectory() *string {
	if o == nil {
		return nil
	}
	return o.RootDirectory
}

func (o *ProjectSettings) GetServerlessFunctionRegion() *string {
	if o == nil {
		return nil
	}
	return o.ServerlessFunctionRegion
}

func (o *ProjectSettings) GetSkipGitConnectDuringLink() *bool {
	if o == nil {
		return nil
	}
	return o.SkipGitConnectDuringLink
}

func (o *ProjectSettings) GetSourceFilesOutsideRootDirectory() *bool {
	if o == nil {
		return nil
	}
	return o.SourceFilesOutsideRootDirectory
}

// Target - Either not defined, `staging`, or `production`. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`
type Target string

const (
	TargetStaging    Target = "staging"
	TargetProduction Target = "production"
)

func (e Target) ToPointer() *Target {
	return &e
}
func (e *Target) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "staging":
		fallthrough
	case "production":
		*e = Target(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Target: %v", v)
	}
}

type CreateDeploymentRequestBody struct {
	// Deploy to a custom environment, which will override the default environment
	CustomEnvironmentSlugOrID *string `json:"customEnvironmentSlugOrId,omitempty"`
	// An deployment id for an existing deployment to redeploy
	DeploymentID *string `json:"deploymentId,omitempty"`
	// A list of objects with the files to be deployed
	Files []Files `json:"files,omitempty"`
	// Populates initial git metadata for different git providers.
	GitMetadata *GitMetadata `json:"gitMetadata,omitempty"`
	// Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
	GitSource *GitSource `json:"gitSource,omitempty"`
	// An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment
	Meta map[string]string `json:"meta,omitempty"`
	// The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected
	MonorepoManager *string `json:"monorepoManager,omitempty"`
	// A string with the project name used in the deployment URL
	Name string `json:"name"`
	// The target project identifier in which the deployment will be created. When defined, this parameter overrides name
	Project *string `json:"project,omitempty"`
	// Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
	ProjectSettings *ProjectSettings `json:"projectSettings,omitempty"`
	// Either not defined, `staging`, or `production`. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`
	Target *Target `json:"target,omitempty"`
	// When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used.
	WithLatestCommit *bool `json:"withLatestCommit,omitempty"`
}

func (o *CreateDeploymentRequestBody) GetCustomEnvironmentSlugOrID() *string {
	if o == nil {
		return nil
	}
	return o.CustomEnvironmentSlugOrID
}

func (o *CreateDeploymentRequestBody) GetDeploymentID() *string {
	if o == nil {
		return nil
	}
	return o.DeploymentID
}

func (o *CreateDeploymentRequestBody) GetFiles() []Files {
	if o == nil {
		return nil
	}
	return o.Files
}

func (o *CreateDeploymentRequestBody) GetGitMetadata() *GitMetadata {
	if o == nil {
		return nil
	}
	return o.GitMetadata
}

func (o *CreateDeploymentRequestBody) GetGitSource() *GitSource {
	if o == nil {
		return nil
	}
	return o.GitSource
}

func (o *CreateDeploymentRequestBody) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *CreateDeploymentRequestBody) GetMonorepoManager() *string {
	if o == nil {
		return nil
	}
	return o.MonorepoManager
}

func (o *CreateDeploymentRequestBody) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentRequestBody) GetProject() *string {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *CreateDeploymentRequestBody) GetProjectSettings() *ProjectSettings {
	if o == nil {
		return nil
	}
	return o.ProjectSettings
}

func (o *CreateDeploymentRequestBody) GetTarget() *Target {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *CreateDeploymentRequestBody) GetWithLatestCommit() *bool {
	if o == nil {
		return nil
	}
	return o.WithLatestCommit
}

type CreateDeploymentRequest struct {
	// Forces a new deployment even if there is a previous similar deployment
	ForceNew *ForceNew `queryParam:"style=form,explode=true,name=forceNew"`
	// Allows to skip framework detection so the API would not fail to ask for confirmation
	SkipAutoDetectionConfirmation *SkipAutoDetectionConfirmation `queryParam:"style=form,explode=true,name=skipAutoDetectionConfirmation"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug        *string                     `queryParam:"style=form,explode=true,name=slug"`
	RequestBody CreateDeploymentRequestBody `request:"mediaType=application/json"`
}

func (o *CreateDeploymentRequest) GetForceNew() *ForceNew {
	if o == nil {
		return nil
	}
	return o.ForceNew
}

func (o *CreateDeploymentRequest) GetSkipAutoDetectionConfirmation() *SkipAutoDetectionConfirmation {
	if o == nil {
		return nil
	}
	return o.SkipAutoDetectionConfirmation
}

func (o *CreateDeploymentRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *CreateDeploymentRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *CreateDeploymentRequest) GetRequestBody() CreateDeploymentRequestBody {
	if o == nil {
		return CreateDeploymentRequestBody{}
	}
	return o.RequestBody
}

type AliasAssignedAtType string

const (
	AliasAssignedAtTypeNumber  AliasAssignedAtType = "number"
	AliasAssignedAtTypeBoolean AliasAssignedAtType = "boolean"
)

type AliasAssignedAt struct {
	Number  *float64
	Boolean *bool

	Type AliasAssignedAtType
}

func CreateAliasAssignedAtNumber(number float64) AliasAssignedAt {
	typ := AliasAssignedAtTypeNumber

	return AliasAssignedAt{
		Number: &number,
		Type:   typ,
	}
}

func CreateAliasAssignedAtBoolean(boolean bool) AliasAssignedAt {
	typ := AliasAssignedAtTypeBoolean

	return AliasAssignedAt{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *AliasAssignedAt) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = AliasAssignedAtTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = &boolean
		u.Type = AliasAssignedAtTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AliasAssignedAt", string(data))
}

func (u AliasAssignedAt) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type AliasAssignedAt: all fields are null")
}

type Build struct {
	Env []string `json:"env"`
}

func (o *Build) GetEnv() []string {
	if o == nil {
		return []string{}
	}
	return o.Env
}

type Builds struct {
}

type CreateDeploymentFramework string

const (
	CreateDeploymentFrameworkBlitzjs        CreateDeploymentFramework = "blitzjs"
	CreateDeploymentFrameworkNextjs         CreateDeploymentFramework = "nextjs"
	CreateDeploymentFrameworkGatsby         CreateDeploymentFramework = "gatsby"
	CreateDeploymentFrameworkRemix          CreateDeploymentFramework = "remix"
	CreateDeploymentFrameworkAstro          CreateDeploymentFramework = "astro"
	CreateDeploymentFrameworkHexo           CreateDeploymentFramework = "hexo"
	CreateDeploymentFrameworkEleventy       CreateDeploymentFramework = "eleventy"
	CreateDeploymentFrameworkDocusaurus2    CreateDeploymentFramework = "docusaurus-2"
	CreateDeploymentFrameworkDocusaurus     CreateDeploymentFramework = "docusaurus"
	CreateDeploymentFrameworkPreact         CreateDeploymentFramework = "preact"
	CreateDeploymentFrameworkSolidstart1    CreateDeploymentFramework = "solidstart-1"
	CreateDeploymentFrameworkSolidstart     CreateDeploymentFramework = "solidstart"
	CreateDeploymentFrameworkDojo           CreateDeploymentFramework = "dojo"
	CreateDeploymentFrameworkEmber          CreateDeploymentFramework = "ember"
	CreateDeploymentFrameworkVue            CreateDeploymentFramework = "vue"
	CreateDeploymentFrameworkScully         CreateDeploymentFramework = "scully"
	CreateDeploymentFrameworkIonicAngular   CreateDeploymentFramework = "ionic-angular"
	CreateDeploymentFrameworkAngular        CreateDeploymentFramework = "angular"
	CreateDeploymentFrameworkPolymer        CreateDeploymentFramework = "polymer"
	CreateDeploymentFrameworkSvelte         CreateDeploymentFramework = "svelte"
	CreateDeploymentFrameworkSveltekit      CreateDeploymentFramework = "sveltekit"
	CreateDeploymentFrameworkSveltekit1     CreateDeploymentFramework = "sveltekit-1"
	CreateDeploymentFrameworkIonicReact     CreateDeploymentFramework = "ionic-react"
	CreateDeploymentFrameworkCreateReactApp CreateDeploymentFramework = "create-react-app"
	CreateDeploymentFrameworkGridsome       CreateDeploymentFramework = "gridsome"
	CreateDeploymentFrameworkUmijs          CreateDeploymentFramework = "umijs"
	CreateDeploymentFrameworkSapper         CreateDeploymentFramework = "sapper"
	CreateDeploymentFrameworkSaber          CreateDeploymentFramework = "saber"
	CreateDeploymentFrameworkStencil        CreateDeploymentFramework = "stencil"
	CreateDeploymentFrameworkNuxtjs         CreateDeploymentFramework = "nuxtjs"
	CreateDeploymentFrameworkRedwoodjs      CreateDeploymentFramework = "redwoodjs"
	CreateDeploymentFrameworkHugo           CreateDeploymentFramework = "hugo"
	CreateDeploymentFrameworkJekyll         CreateDeploymentFramework = "jekyll"
	CreateDeploymentFrameworkBrunch         CreateDeploymentFramework = "brunch"
	CreateDeploymentFrameworkMiddleman      CreateDeploymentFramework = "middleman"
	CreateDeploymentFrameworkZola           CreateDeploymentFramework = "zola"
	CreateDeploymentFrameworkHydrogen       CreateDeploymentFramework = "hydrogen"
	CreateDeploymentFrameworkVite           CreateDeploymentFramework = "vite"
	CreateDeploymentFrameworkVitepress      CreateDeploymentFramework = "vitepress"
	CreateDeploymentFrameworkVuepress       CreateDeploymentFramework = "vuepress"
	CreateDeploymentFrameworkParcel         CreateDeploymentFramework = "parcel"
	CreateDeploymentFrameworkFasthtml       CreateDeploymentFramework = "fasthtml"
	CreateDeploymentFrameworkSanityV3       CreateDeploymentFramework = "sanity-v3"
	CreateDeploymentFrameworkSanity         CreateDeploymentFramework = "sanity"
	CreateDeploymentFrameworkStorybook      CreateDeploymentFramework = "storybook"
)

func (e CreateDeploymentFramework) ToPointer() *CreateDeploymentFramework {
	return &e
}
func (e *CreateDeploymentFramework) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blitzjs":
		fallthrough
	case "nextjs":
		fallthrough
	case "gatsby":
		fallthrough
	case "remix":
		fallthrough
	case "astro":
		fallthrough
	case "hexo":
		fallthrough
	case "eleventy":
		fallthrough
	case "docusaurus-2":
		fallthrough
	case "docusaurus":
		fallthrough
	case "preact":
		fallthrough
	case "solidstart-1":
		fallthrough
	case "solidstart":
		fallthrough
	case "dojo":
		fallthrough
	case "ember":
		fallthrough
	case "vue":
		fallthrough
	case "scully":
		fallthrough
	case "ionic-angular":
		fallthrough
	case "angular":
		fallthrough
	case "polymer":
		fallthrough
	case "svelte":
		fallthrough
	case "sveltekit":
		fallthrough
	case "sveltekit-1":
		fallthrough
	case "ionic-react":
		fallthrough
	case "create-react-app":
		fallthrough
	case "gridsome":
		fallthrough
	case "umijs":
		fallthrough
	case "sapper":
		fallthrough
	case "saber":
		fallthrough
	case "stencil":
		fallthrough
	case "nuxtjs":
		fallthrough
	case "redwoodjs":
		fallthrough
	case "hugo":
		fallthrough
	case "jekyll":
		fallthrough
	case "brunch":
		fallthrough
	case "middleman":
		fallthrough
	case "zola":
		fallthrough
	case "hydrogen":
		fallthrough
	case "vite":
		fallthrough
	case "vitepress":
		fallthrough
	case "vuepress":
		fallthrough
	case "parcel":
		fallthrough
	case "fasthtml":
		fallthrough
	case "sanity-v3":
		fallthrough
	case "sanity":
		fallthrough
	case "storybook":
		*e = CreateDeploymentFramework(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentFramework: %v", v)
	}
}

type CreateDeploymentSpeedInsights struct {
	ID         string   `json:"id"`
	EnabledAt  *float64 `json:"enabledAt,omitempty"`
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	CanceledAt *float64 `json:"canceledAt,omitempty"`
	HasData    *bool    `json:"hasData,omitempty"`
	PaidAt     *float64 `json:"paidAt,omitempty"`
}

func (o *CreateDeploymentSpeedInsights) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentSpeedInsights) GetEnabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.EnabledAt
}

func (o *CreateDeploymentSpeedInsights) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *CreateDeploymentSpeedInsights) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *CreateDeploymentSpeedInsights) GetHasData() *bool {
	if o == nil {
		return nil
	}
	return o.HasData
}

func (o *CreateDeploymentSpeedInsights) GetPaidAt() *float64 {
	if o == nil {
		return nil
	}
	return o.PaidAt
}

type CreateDeploymentWebAnalytics struct {
	ID         string   `json:"id"`
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	CanceledAt *float64 `json:"canceledAt,omitempty"`
	EnabledAt  *float64 `json:"enabledAt,omitempty"`
	HasData    *bool    `json:"hasData,omitempty"`
}

func (o *CreateDeploymentWebAnalytics) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentWebAnalytics) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *CreateDeploymentWebAnalytics) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *CreateDeploymentWebAnalytics) GetEnabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.EnabledAt
}

func (o *CreateDeploymentWebAnalytics) GetHasData() *bool {
	if o == nil {
		return nil
	}
	return o.HasData
}

type CreateDeploymentProjectSettings struct {
	BuildCommand                *string                        `json:"buildCommand,omitempty"`
	CommandForIgnoringBuildStep *string                        `json:"commandForIgnoringBuildStep,omitempty"`
	DevCommand                  *string                        `json:"devCommand,omitempty"`
	Framework                   *CreateDeploymentFramework     `json:"framework,omitempty"`
	InstallCommand              *string                        `json:"installCommand,omitempty"`
	OutputDirectory             *string                        `json:"outputDirectory,omitempty"`
	SpeedInsights               *CreateDeploymentSpeedInsights `json:"speedInsights,omitempty"`
	WebAnalytics                *CreateDeploymentWebAnalytics  `json:"webAnalytics,omitempty"`
}

func (o *CreateDeploymentProjectSettings) GetBuildCommand() *string {
	if o == nil {
		return nil
	}
	return o.BuildCommand
}

func (o *CreateDeploymentProjectSettings) GetCommandForIgnoringBuildStep() *string {
	if o == nil {
		return nil
	}
	return o.CommandForIgnoringBuildStep
}

func (o *CreateDeploymentProjectSettings) GetDevCommand() *string {
	if o == nil {
		return nil
	}
	return o.DevCommand
}

func (o *CreateDeploymentProjectSettings) GetFramework() *CreateDeploymentFramework {
	if o == nil {
		return nil
	}
	return o.Framework
}

func (o *CreateDeploymentProjectSettings) GetInstallCommand() *string {
	if o == nil {
		return nil
	}
	return o.InstallCommand
}

func (o *CreateDeploymentProjectSettings) GetOutputDirectory() *string {
	if o == nil {
		return nil
	}
	return o.OutputDirectory
}

func (o *CreateDeploymentProjectSettings) GetSpeedInsights() *CreateDeploymentSpeedInsights {
	if o == nil {
		return nil
	}
	return o.SpeedInsights
}

func (o *CreateDeploymentProjectSettings) GetWebAnalytics() *CreateDeploymentWebAnalytics {
	if o == nil {
		return nil
	}
	return o.WebAnalytics
}

type CreateDeploymentDeploymentsStatus string

const (
	CreateDeploymentDeploymentsStatusError   CreateDeploymentDeploymentsStatus = "error"
	CreateDeploymentDeploymentsStatusSkipped CreateDeploymentDeploymentsStatus = "skipped"
	CreateDeploymentDeploymentsStatusPending CreateDeploymentDeploymentsStatus = "pending"
	CreateDeploymentDeploymentsStatusReady   CreateDeploymentDeploymentsStatus = "ready"
	CreateDeploymentDeploymentsStatusTimeout CreateDeploymentDeploymentsStatus = "timeout"
)

func (e CreateDeploymentDeploymentsStatus) ToPointer() *CreateDeploymentDeploymentsStatus {
	return &e
}
func (e *CreateDeploymentDeploymentsStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "error":
		fallthrough
	case "skipped":
		fallthrough
	case "pending":
		fallthrough
	case "ready":
		fallthrough
	case "timeout":
		*e = CreateDeploymentDeploymentsStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentDeploymentsStatus: %v", v)
	}
}

type Integrations struct {
	Status      CreateDeploymentDeploymentsStatus `json:"status"`
	StartedAt   float64                           `json:"startedAt"`
	CompletedAt *float64                          `json:"completedAt,omitempty"`
	SkippedAt   *float64                          `json:"skippedAt,omitempty"`
	SkippedBy   *string                           `json:"skippedBy,omitempty"`
}

func (o *Integrations) GetStatus() CreateDeploymentDeploymentsStatus {
	if o == nil {
		return CreateDeploymentDeploymentsStatus("")
	}
	return o.Status
}

func (o *Integrations) GetStartedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.StartedAt
}

func (o *Integrations) GetCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

func (o *Integrations) GetSkippedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.SkippedAt
}

func (o *Integrations) GetSkippedBy() *string {
	if o == nil {
		return nil
	}
	return o.SkippedBy
}

// Protocol - Must be `http` or `https`.
type Protocol string

const (
	ProtocolHTTP  Protocol = "http"
	ProtocolHTTPS Protocol = "https"
)

func (e Protocol) ToPointer() *Protocol {
	return &e
}
func (e *Protocol) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		fallthrough
	case "https":
		*e = Protocol(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Protocol: %v", v)
	}
}

type RemotePatterns struct {
	// Must be `http` or `https`.
	Protocol *Protocol `json:"protocol,omitempty"`
	// Can be literal or wildcard. Single `*` matches a single subdomain. Double `**` matches any number of subdomains.
	Hostname string `json:"hostname"`
	// Can be literal port such as `8080` or empty string meaning no port.
	Port *string `json:"port,omitempty"`
	// Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.
	Pathname *string `json:"pathname,omitempty"`
	// Can be literal query string such as `?v=1` or empty string meaning no query string.
	Search *string `json:"search,omitempty"`
}

func (o *RemotePatterns) GetProtocol() *Protocol {
	if o == nil {
		return nil
	}
	return o.Protocol
}

func (o *RemotePatterns) GetHostname() string {
	if o == nil {
		return ""
	}
	return o.Hostname
}

func (o *RemotePatterns) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *RemotePatterns) GetPathname() *string {
	if o == nil {
		return nil
	}
	return o.Pathname
}

func (o *RemotePatterns) GetSearch() *string {
	if o == nil {
		return nil
	}
	return o.Search
}

type LocalPatterns struct {
	// Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.
	Pathname *string `json:"pathname,omitempty"`
	// Can be literal query string such as `?v=1` or empty string meaning no query string.
	Search *string `json:"search,omitempty"`
}

func (o *LocalPatterns) GetPathname() *string {
	if o == nil {
		return nil
	}
	return o.Pathname
}

func (o *LocalPatterns) GetSearch() *string {
	if o == nil {
		return nil
	}
	return o.Search
}

type Formats string

const (
	FormatsImageAvif Formats = "image/avif"
	FormatsImageWebp Formats = "image/webp"
)

func (e Formats) ToPointer() *Formats {
	return &e
}
func (e *Formats) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "image/avif":
		fallthrough
	case "image/webp":
		*e = Formats(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Formats: %v", v)
	}
}

type ContentDispositionType string

const (
	ContentDispositionTypeInline     ContentDispositionType = "inline"
	ContentDispositionTypeAttachment ContentDispositionType = "attachment"
)

func (e ContentDispositionType) ToPointer() *ContentDispositionType {
	return &e
}
func (e *ContentDispositionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "inline":
		fallthrough
	case "attachment":
		*e = ContentDispositionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ContentDispositionType: %v", v)
	}
}

type Images struct {
	Sizes                  []float64               `json:"sizes,omitempty"`
	Qualities              []float64               `json:"qualities,omitempty"`
	Domains                []string                `json:"domains,omitempty"`
	RemotePatterns         []RemotePatterns        `json:"remotePatterns,omitempty"`
	LocalPatterns          []LocalPatterns         `json:"localPatterns,omitempty"`
	MinimumCacheTTL        *float64                `json:"minimumCacheTTL,omitempty"`
	Formats                []Formats               `json:"formats,omitempty"`
	DangerouslyAllowSVG    *bool                   `json:"dangerouslyAllowSVG,omitempty"`
	ContentSecurityPolicy  *string                 `json:"contentSecurityPolicy,omitempty"`
	ContentDispositionType *ContentDispositionType `json:"contentDispositionType,omitempty"`
}

func (o *Images) GetSizes() []float64 {
	if o == nil {
		return nil
	}
	return o.Sizes
}

func (o *Images) GetQualities() []float64 {
	if o == nil {
		return nil
	}
	return o.Qualities
}

func (o *Images) GetDomains() []string {
	if o == nil {
		return nil
	}
	return o.Domains
}

func (o *Images) GetRemotePatterns() []RemotePatterns {
	if o == nil {
		return nil
	}
	return o.RemotePatterns
}

func (o *Images) GetLocalPatterns() []LocalPatterns {
	if o == nil {
		return nil
	}
	return o.LocalPatterns
}

func (o *Images) GetMinimumCacheTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.MinimumCacheTTL
}

func (o *Images) GetFormats() []Formats {
	if o == nil {
		return nil
	}
	return o.Formats
}

func (o *Images) GetDangerouslyAllowSVG() *bool {
	if o == nil {
		return nil
	}
	return o.DangerouslyAllowSVG
}

func (o *Images) GetContentSecurityPolicy() *string {
	if o == nil {
		return nil
	}
	return o.ContentSecurityPolicy
}

func (o *Images) GetContentDispositionType() *ContentDispositionType {
	if o == nil {
		return nil
	}
	return o.ContentDispositionType
}

type Creator struct {
	UID      string  `json:"uid"`
	Username *string `json:"username,omitempty"`
	Avatar   *string `json:"avatar,omitempty"`
}

func (o *Creator) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *Creator) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

func (o *Creator) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

type CreateDeploymentReadyState string

const (
	CreateDeploymentReadyStateBuilding     CreateDeploymentReadyState = "BUILDING"
	CreateDeploymentReadyStateError        CreateDeploymentReadyState = "ERROR"
	CreateDeploymentReadyStateInitializing CreateDeploymentReadyState = "INITIALIZING"
	CreateDeploymentReadyStateReady        CreateDeploymentReadyState = "READY"
)

func (e CreateDeploymentReadyState) ToPointer() *CreateDeploymentReadyState {
	return &e
}
func (e *CreateDeploymentReadyState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BUILDING":
		fallthrough
	case "ERROR":
		fallthrough
	case "INITIALIZING":
		fallthrough
	case "READY":
		*e = CreateDeploymentReadyState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentReadyState: %v", v)
	}
}

type CreateDeploymentOutput struct {
	Path         string `json:"path"`
	FunctionName string `json:"functionName"`
}

func (o *CreateDeploymentOutput) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *CreateDeploymentOutput) GetFunctionName() string {
	if o == nil {
		return ""
	}
	return o.FunctionName
}

// Lambdas - A partial representation of a Build used by the deployment endpoint.
type Lambdas struct {
	ID           *string                     `json:"id,omitempty"`
	CreatedAt    *float64                    `json:"createdAt,omitempty"`
	Entrypoint   *string                     `json:"entrypoint,omitempty"`
	ReadyState   *CreateDeploymentReadyState `json:"readyState,omitempty"`
	ReadyStateAt *float64                    `json:"readyStateAt,omitempty"`
	Output       []CreateDeploymentOutput    `json:"output"`
}

func (o *Lambdas) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Lambdas) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Lambdas) GetEntrypoint() *string {
	if o == nil {
		return nil
	}
	return o.Entrypoint
}

func (o *Lambdas) GetReadyState() *CreateDeploymentReadyState {
	if o == nil {
		return nil
	}
	return o.ReadyState
}

func (o *Lambdas) GetReadyStateAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ReadyStateAt
}

func (o *Lambdas) GetOutput() []CreateDeploymentOutput {
	if o == nil {
		return []CreateDeploymentOutput{}
	}
	return o.Output
}

type CreateDeploymentStatus string

const (
	CreateDeploymentStatusCanceled     CreateDeploymentStatus = "CANCELED"
	CreateDeploymentStatusError        CreateDeploymentStatus = "ERROR"
	CreateDeploymentStatusQueued       CreateDeploymentStatus = "QUEUED"
	CreateDeploymentStatusBuilding     CreateDeploymentStatus = "BUILDING"
	CreateDeploymentStatusInitializing CreateDeploymentStatus = "INITIALIZING"
	CreateDeploymentStatusReady        CreateDeploymentStatus = "READY"
)

func (e CreateDeploymentStatus) ToPointer() *CreateDeploymentStatus {
	return &e
}
func (e *CreateDeploymentStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CANCELED":
		fallthrough
	case "ERROR":
		fallthrough
	case "QUEUED":
		fallthrough
	case "BUILDING":
		fallthrough
	case "INITIALIZING":
		fallthrough
	case "READY":
		*e = CreateDeploymentStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentStatus: %v", v)
	}
}

type Team struct {
	Name   string  `json:"name"`
	ID     string  `json:"id"`
	Slug   string  `json:"slug"`
	Avatar *string `json:"avatar,omitempty"`
}

func (o *Team) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Team) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Team) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *Team) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

type CustomEnvironment2 struct {
	ID string `json:"id"`
}

func (o *CustomEnvironment2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

type CustomEnvironment1 struct {
}

type CustomEnvironmentType string

const (
	CustomEnvironmentTypeCustomEnvironment1 CustomEnvironmentType = "customEnvironment_1"
	CustomEnvironmentTypeCustomEnvironment2 CustomEnvironmentType = "customEnvironment_2"
)

type CustomEnvironment struct {
	CustomEnvironment1 *CustomEnvironment1
	CustomEnvironment2 *CustomEnvironment2

	Type CustomEnvironmentType
}

func CreateCustomEnvironmentCustomEnvironment1(customEnvironment1 CustomEnvironment1) CustomEnvironment {
	typ := CustomEnvironmentTypeCustomEnvironment1

	return CustomEnvironment{
		CustomEnvironment1: &customEnvironment1,
		Type:               typ,
	}
}

func CreateCustomEnvironmentCustomEnvironment2(customEnvironment2 CustomEnvironment2) CustomEnvironment {
	typ := CustomEnvironmentTypeCustomEnvironment2

	return CustomEnvironment{
		CustomEnvironment2: &customEnvironment2,
		Type:               typ,
	}
}

func (u *CustomEnvironment) UnmarshalJSON(data []byte) error {

	var customEnvironment1 CustomEnvironment1 = CustomEnvironment1{}
	if err := utils.UnmarshalJSON(data, &customEnvironment1, "", true, true); err == nil {
		u.CustomEnvironment1 = &customEnvironment1
		u.Type = CustomEnvironmentTypeCustomEnvironment1
		return nil
	}

	var customEnvironment2 CustomEnvironment2 = CustomEnvironment2{}
	if err := utils.UnmarshalJSON(data, &customEnvironment2, "", true, true); err == nil {
		u.CustomEnvironment2 = &customEnvironment2
		u.Type = CustomEnvironmentTypeCustomEnvironment2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CustomEnvironment", string(data))
}

func (u CustomEnvironment) MarshalJSON() ([]byte, error) {
	if u.CustomEnvironment1 != nil {
		return utils.MarshalJSON(u.CustomEnvironment1, "", true)
	}

	if u.CustomEnvironment2 != nil {
		return utils.MarshalJSON(u.CustomEnvironment2, "", true)
	}

	return nil, errors.New("could not marshal union type CustomEnvironment: all fields are null")
}

type CreateDeploymentType string

const (
	CreateDeploymentTypeLambdas CreateDeploymentType = "LAMBDAS"
)

func (e CreateDeploymentType) ToPointer() *CreateDeploymentType {
	return &e
}
func (e *CreateDeploymentType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LAMBDAS":
		*e = CreateDeploymentType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentType: %v", v)
	}
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9TypeBitbucket CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type: %v", v)
	}
}

type CreateDeploymentGitSource9 struct {
	Type          CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type `json:"type"`
	Ref           string                                                                          `json:"ref"`
	Sha           string                                                                          `json:"sha"`
	Owner         *string                                                                         `json:"owner,omitempty"`
	Slug          *string                                                                         `json:"slug,omitempty"`
	WorkspaceUUID string                                                                          `json:"workspaceUuid"`
	RepoUUID      string                                                                          `json:"repoUuid"`
}

func (o *CreateDeploymentGitSource9) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSource9) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSource9) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSource9) GetOwner() *string {
	if o == nil {
		return nil
	}
	return o.Owner
}

func (o *CreateDeploymentGitSource9) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *CreateDeploymentGitSource9) GetWorkspaceUUID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceUUID
}

func (o *CreateDeploymentGitSource9) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8TypeGitlab CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type = "gitlab"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type: %v", v)
	}
}

type CreateDeploymentGitSource8 struct {
	Type      CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type `json:"type"`
	Ref       string                                                                          `json:"ref"`
	Sha       string                                                                          `json:"sha"`
	ProjectID float64                                                                         `json:"projectId"`
}

func (o *CreateDeploymentGitSource8) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSource8) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSource8) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSource8) GetProjectID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ProjectID
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7TypeGithub CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type = "github"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type: %v", v)
	}
}

type CreateDeploymentGitSource7 struct {
	Type   CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type `json:"type"`
	Ref    string                                                                          `json:"ref"`
	Sha    string                                                                          `json:"sha"`
	RepoID float64                                                                         `json:"repoId"`
	Org    *string                                                                         `json:"org,omitempty"`
	Repo   *string                                                                         `json:"repo,omitempty"`
}

func (o *CreateDeploymentGitSource7) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSource7) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSource7) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSource7) GetRepoID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoID
}

func (o *CreateDeploymentGitSource7) GetOrg() *string {
	if o == nil {
		return nil
	}
	return o.Org
}

func (o *CreateDeploymentGitSource7) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6TypeCustom CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type = "custom"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "custom":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type: %v", v)
	}
}

// CreateDeploymentGitSource6 - Allows custom git sources (local folder mounted to the container) in test mode
type CreateDeploymentGitSource6 struct {
	Type   CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type `json:"type"`
	Ref    string                                                                          `json:"ref"`
	Sha    string                                                                          `json:"sha"`
	GitURL string                                                                          `json:"gitUrl"`
}

func (o *CreateDeploymentGitSource6) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSource6) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSource6) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSource6) GetGitURL() string {
	if o == nil {
		return ""
	}
	return o.GitURL
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5TypeBitbucket CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type: %v", v)
	}
}

type GitSource5 struct {
	Type  CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type `json:"type"`
	Owner string                                                                          `json:"owner"`
	Slug  string                                                                          `json:"slug"`
	Ref   *string                                                                         `json:"ref,omitempty"`
	Sha   *string                                                                         `json:"sha,omitempty"`
	PrID  *float64                                                                        `json:"prId,omitempty"`
}

func (o *GitSource5) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type("")
	}
	return o.Type
}

func (o *GitSource5) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *GitSource5) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GitSource5) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource5) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource5) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyTypeBitbucket CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType: %v", v)
	}
}

type GitSource4 struct {
	Type          CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType `json:"type"`
	WorkspaceUUID *string                                                                        `json:"workspaceUuid,omitempty"`
	RepoUUID      string                                                                         `json:"repoUuid"`
	Ref           *string                                                                        `json:"ref,omitempty"`
	Sha           *string                                                                        `json:"sha,omitempty"`
	PrID          *float64                                                                       `json:"prId,omitempty"`
}

func (o *GitSource4) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType("")
	}
	return o.Type
}

func (o *GitSource4) GetWorkspaceUUID() *string {
	if o == nil {
		return nil
	}
	return o.WorkspaceUUID
}

func (o *GitSource4) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *GitSource4) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource4) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource4) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONTypeGitlab CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType = "gitlab"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType: %v", v)
	}
}

type GitSourceProjectIDType string

const (
	GitSourceProjectIDTypeStr    GitSourceProjectIDType = "str"
	GitSourceProjectIDTypeNumber GitSourceProjectIDType = "number"
)

type GitSourceProjectID struct {
	Str    *string
	Number *float64

	Type GitSourceProjectIDType
}

func CreateGitSourceProjectIDStr(str string) GitSourceProjectID {
	typ := GitSourceProjectIDTypeStr

	return GitSourceProjectID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGitSourceProjectIDNumber(number float64) GitSourceProjectID {
	typ := GitSourceProjectIDTypeNumber

	return GitSourceProjectID{
		Number: &number,
		Type:   typ,
	}
}

func (u *GitSourceProjectID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = GitSourceProjectIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = GitSourceProjectIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitSourceProjectID", string(data))
}

func (u GitSourceProjectID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GitSourceProjectID: all fields are null")
}

type GitSource3 struct {
	Type      CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType `json:"type"`
	ProjectID GitSourceProjectID                                                 `json:"projectId"`
	Ref       *string                                                            `json:"ref,omitempty"`
	Sha       *string                                                            `json:"sha,omitempty"`
	PrID      *float64                                                           `json:"prId,omitempty"`
}

func (o *GitSource3) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType("")
	}
	return o.Type
}

func (o *GitSource3) GetProjectID() GitSourceProjectID {
	if o == nil {
		return GitSourceProjectID{}
	}
	return o.ProjectID
}

func (o *GitSource3) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource3) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource3) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceDeploymentsResponse200Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200TypeGithub CreateDeploymentGitSourceDeploymentsResponse200Type = "github"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitSourceDeploymentsResponse200Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200Type: %v", v)
	}
}

type GitSource2 struct {
	Type CreateDeploymentGitSourceDeploymentsResponse200Type `json:"type"`
	Org  string                                              `json:"org"`
	Repo string                                              `json:"repo"`
	Ref  *string                                             `json:"ref,omitempty"`
	Sha  *string                                             `json:"sha,omitempty"`
	PrID *float64                                            `json:"prId,omitempty"`
}

func (o *GitSource2) GetType() CreateDeploymentGitSourceDeploymentsResponse200Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200Type("")
	}
	return o.Type
}

func (o *GitSource2) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GitSource2) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *GitSource2) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource2) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource2) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceDeploymentsResponseType string

const (
	CreateDeploymentGitSourceDeploymentsResponseTypeGithub CreateDeploymentGitSourceDeploymentsResponseType = "github"
)

func (e CreateDeploymentGitSourceDeploymentsResponseType) ToPointer() *CreateDeploymentGitSourceDeploymentsResponseType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponseType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitSourceDeploymentsResponseType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponseType: %v", v)
	}
}

type GitSourceRepoIDType string

const (
	GitSourceRepoIDTypeStr    GitSourceRepoIDType = "str"
	GitSourceRepoIDTypeNumber GitSourceRepoIDType = "number"
)

type GitSourceRepoID struct {
	Str    *string
	Number *float64

	Type GitSourceRepoIDType
}

func CreateGitSourceRepoIDStr(str string) GitSourceRepoID {
	typ := GitSourceRepoIDTypeStr

	return GitSourceRepoID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGitSourceRepoIDNumber(number float64) GitSourceRepoID {
	typ := GitSourceRepoIDTypeNumber

	return GitSourceRepoID{
		Number: &number,
		Type:   typ,
	}
}

func (u *GitSourceRepoID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = GitSourceRepoIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = GitSourceRepoIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitSourceRepoID", string(data))
}

func (u GitSourceRepoID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GitSourceRepoID: all fields are null")
}

type GitSource1 struct {
	Type   CreateDeploymentGitSourceDeploymentsResponseType `json:"type"`
	RepoID GitSourceRepoID                                  `json:"repoId"`
	Ref    *string                                          `json:"ref,omitempty"`
	Sha    *string                                          `json:"sha,omitempty"`
	PrID   *float64                                         `json:"prId,omitempty"`
}

func (o *GitSource1) GetType() CreateDeploymentGitSourceDeploymentsResponseType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponseType("")
	}
	return o.Type
}

func (o *GitSource1) GetRepoID() GitSourceRepoID {
	if o == nil {
		return GitSourceRepoID{}
	}
	return o.RepoID
}

func (o *GitSource1) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource1) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceUnionType string

const (
	CreateDeploymentGitSourceUnionTypeGitSource1                 CreateDeploymentGitSourceUnionType = "gitSource_1"
	CreateDeploymentGitSourceUnionTypeGitSource2                 CreateDeploymentGitSourceUnionType = "gitSource_2"
	CreateDeploymentGitSourceUnionTypeGitSource3                 CreateDeploymentGitSourceUnionType = "gitSource_3"
	CreateDeploymentGitSourceUnionTypeGitSource4                 CreateDeploymentGitSourceUnionType = "gitSource_4"
	CreateDeploymentGitSourceUnionTypeGitSource5                 CreateDeploymentGitSourceUnionType = "gitSource_5"
	CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource6 CreateDeploymentGitSourceUnionType = "createDeployment_gitSource_6"
	CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource7 CreateDeploymentGitSourceUnionType = "createDeployment_gitSource_7"
	CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource8 CreateDeploymentGitSourceUnionType = "createDeployment_gitSource_8"
	CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource9 CreateDeploymentGitSourceUnionType = "createDeployment_gitSource_9"
)

type CreateDeploymentGitSource struct {
	GitSource1                 *GitSource1
	GitSource2                 *GitSource2
	GitSource3                 *GitSource3
	GitSource4                 *GitSource4
	GitSource5                 *GitSource5
	CreateDeploymentGitSource6 *CreateDeploymentGitSource6
	CreateDeploymentGitSource7 *CreateDeploymentGitSource7
	CreateDeploymentGitSource8 *CreateDeploymentGitSource8
	CreateDeploymentGitSource9 *CreateDeploymentGitSource9

	Type CreateDeploymentGitSourceUnionType
}

func CreateCreateDeploymentGitSourceGitSource1(gitSource1 GitSource1) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource1

	return CreateDeploymentGitSource{
		GitSource1: &gitSource1,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceGitSource2(gitSource2 GitSource2) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource2

	return CreateDeploymentGitSource{
		GitSource2: &gitSource2,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceGitSource3(gitSource3 GitSource3) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource3

	return CreateDeploymentGitSource{
		GitSource3: &gitSource3,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceGitSource4(gitSource4 GitSource4) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource4

	return CreateDeploymentGitSource{
		GitSource4: &gitSource4,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceGitSource5(gitSource5 GitSource5) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource5

	return CreateDeploymentGitSource{
		GitSource5: &gitSource5,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceCreateDeploymentGitSource6(createDeploymentGitSource6 CreateDeploymentGitSource6) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource6

	return CreateDeploymentGitSource{
		CreateDeploymentGitSource6: &createDeploymentGitSource6,
		Type:                       typ,
	}
}

func CreateCreateDeploymentGitSourceCreateDeploymentGitSource7(createDeploymentGitSource7 CreateDeploymentGitSource7) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource7

	return CreateDeploymentGitSource{
		CreateDeploymentGitSource7: &createDeploymentGitSource7,
		Type:                       typ,
	}
}

func CreateCreateDeploymentGitSourceCreateDeploymentGitSource8(createDeploymentGitSource8 CreateDeploymentGitSource8) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource8

	return CreateDeploymentGitSource{
		CreateDeploymentGitSource8: &createDeploymentGitSource8,
		Type:                       typ,
	}
}

func CreateCreateDeploymentGitSourceCreateDeploymentGitSource9(createDeploymentGitSource9 CreateDeploymentGitSource9) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource9

	return CreateDeploymentGitSource{
		CreateDeploymentGitSource9: &createDeploymentGitSource9,
		Type:                       typ,
	}
}

func (u *CreateDeploymentGitSource) UnmarshalJSON(data []byte) error {

	var createDeploymentGitSource6 CreateDeploymentGitSource6 = CreateDeploymentGitSource6{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSource6, "", true, true); err == nil {
		u.CreateDeploymentGitSource6 = &createDeploymentGitSource6
		u.Type = CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource6
		return nil
	}

	var createDeploymentGitSource8 CreateDeploymentGitSource8 = CreateDeploymentGitSource8{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSource8, "", true, true); err == nil {
		u.CreateDeploymentGitSource8 = &createDeploymentGitSource8
		u.Type = CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource8
		return nil
	}

	var gitSource1 GitSource1 = GitSource1{}
	if err := utils.UnmarshalJSON(data, &gitSource1, "", true, true); err == nil {
		u.GitSource1 = &gitSource1
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource1
		return nil
	}

	var gitSource3 GitSource3 = GitSource3{}
	if err := utils.UnmarshalJSON(data, &gitSource3, "", true, true); err == nil {
		u.GitSource3 = &gitSource3
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource3
		return nil
	}

	var gitSource2 GitSource2 = GitSource2{}
	if err := utils.UnmarshalJSON(data, &gitSource2, "", true, true); err == nil {
		u.GitSource2 = &gitSource2
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource2
		return nil
	}

	var gitSource4 GitSource4 = GitSource4{}
	if err := utils.UnmarshalJSON(data, &gitSource4, "", true, true); err == nil {
		u.GitSource4 = &gitSource4
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource4
		return nil
	}

	var gitSource5 GitSource5 = GitSource5{}
	if err := utils.UnmarshalJSON(data, &gitSource5, "", true, true); err == nil {
		u.GitSource5 = &gitSource5
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource5
		return nil
	}

	var createDeploymentGitSource7 CreateDeploymentGitSource7 = CreateDeploymentGitSource7{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSource7, "", true, true); err == nil {
		u.CreateDeploymentGitSource7 = &createDeploymentGitSource7
		u.Type = CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource7
		return nil
	}

	var createDeploymentGitSource9 CreateDeploymentGitSource9 = CreateDeploymentGitSource9{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSource9, "", true, true); err == nil {
		u.CreateDeploymentGitSource9 = &createDeploymentGitSource9
		u.Type = CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource9
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentGitSource", string(data))
}

func (u CreateDeploymentGitSource) MarshalJSON() ([]byte, error) {
	if u.GitSource1 != nil {
		return utils.MarshalJSON(u.GitSource1, "", true)
	}

	if u.GitSource2 != nil {
		return utils.MarshalJSON(u.GitSource2, "", true)
	}

	if u.GitSource3 != nil {
		return utils.MarshalJSON(u.GitSource3, "", true)
	}

	if u.GitSource4 != nil {
		return utils.MarshalJSON(u.GitSource4, "", true)
	}

	if u.GitSource5 != nil {
		return utils.MarshalJSON(u.GitSource5, "", true)
	}

	if u.CreateDeploymentGitSource6 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSource6, "", true)
	}

	if u.CreateDeploymentGitSource7 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSource7, "", true)
	}

	if u.CreateDeploymentGitSource8 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSource8, "", true)
	}

	if u.CreateDeploymentGitSource9 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSource9, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentGitSource: all fields are null")
}

type Project struct {
	ID        string  `json:"id"`
	Name      string  `json:"name"`
	Framework *string `json:"framework,omitempty"`
}

func (o *Project) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Project) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Project) GetFramework() *string {
	if o == nil {
		return nil
	}
	return o.Framework
}

type ReadyState string

const (
	ReadyStateCanceled     ReadyState = "CANCELED"
	ReadyStateError        ReadyState = "ERROR"
	ReadyStateQueued       ReadyState = "QUEUED"
	ReadyStateBuilding     ReadyState = "BUILDING"
	ReadyStateInitializing ReadyState = "INITIALIZING"
	ReadyStateReady        ReadyState = "READY"
)

func (e ReadyState) ToPointer() *ReadyState {
	return &e
}
func (e *ReadyState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CANCELED":
		fallthrough
	case "ERROR":
		fallthrough
	case "QUEUED":
		fallthrough
	case "BUILDING":
		fallthrough
	case "INITIALIZING":
		fallthrough
	case "READY":
		*e = ReadyState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReadyState: %v", v)
	}
}

type CreateDeploymentSource string

const (
	CreateDeploymentSourceCli                 CreateDeploymentSource = "cli"
	CreateDeploymentSourceGit                 CreateDeploymentSource = "git"
	CreateDeploymentSourceImport              CreateDeploymentSource = "import"
	CreateDeploymentSourceImportRepo          CreateDeploymentSource = "import/repo"
	CreateDeploymentSourceCloneRepo           CreateDeploymentSource = "clone/repo"
	CreateDeploymentSourceAPITriggerGitDeploy CreateDeploymentSource = "api-trigger-git-deploy"
	CreateDeploymentSourceRedeploy            CreateDeploymentSource = "redeploy"
	CreateDeploymentSourceV0Web               CreateDeploymentSource = "v0-web"
)

func (e CreateDeploymentSource) ToPointer() *CreateDeploymentSource {
	return &e
}
func (e *CreateDeploymentSource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cli":
		fallthrough
	case "git":
		fallthrough
	case "import":
		fallthrough
	case "import/repo":
		fallthrough
	case "clone/repo":
		fallthrough
	case "api-trigger-git-deploy":
		fallthrough
	case "redeploy":
		fallthrough
	case "v0-web":
		*e = CreateDeploymentSource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentSource: %v", v)
	}
}

type CreateDeploymentTarget string

const (
	CreateDeploymentTargetStaging    CreateDeploymentTarget = "staging"
	CreateDeploymentTargetProduction CreateDeploymentTarget = "production"
)

func (e CreateDeploymentTarget) ToPointer() *CreateDeploymentTarget {
	return &e
}
func (e *CreateDeploymentTarget) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "staging":
		fallthrough
	case "production":
		*e = CreateDeploymentTarget(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTarget: %v", v)
	}
}

type AliasWarning struct {
	Code    string  `json:"code"`
	Message string  `json:"message"`
	Link    *string `json:"link,omitempty"`
	Action  *string `json:"action,omitempty"`
}

func (o *AliasWarning) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *AliasWarning) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

func (o *AliasWarning) GetLink() *string {
	if o == nil {
		return nil
	}
	return o.Link
}

func (o *AliasWarning) GetAction() *string {
	if o == nil {
		return nil
	}
	return o.Action
}

type AliasError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (o *AliasError) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *AliasError) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

type ChecksState string

const (
	ChecksStateRegistered ChecksState = "registered"
	ChecksStateRunning    ChecksState = "running"
	ChecksStateCompleted  ChecksState = "completed"
)

func (e ChecksState) ToPointer() *ChecksState {
	return &e
}
func (e *ChecksState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "registered":
		fallthrough
	case "running":
		fallthrough
	case "completed":
		*e = ChecksState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChecksState: %v", v)
	}
}

type ChecksConclusion string

const (
	ChecksConclusionSucceeded ChecksConclusion = "succeeded"
	ChecksConclusionFailed    ChecksConclusion = "failed"
	ChecksConclusionSkipped   ChecksConclusion = "skipped"
	ChecksConclusionCanceled  ChecksConclusion = "canceled"
)

func (e ChecksConclusion) ToPointer() *ChecksConclusion {
	return &e
}
func (e *ChecksConclusion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "succeeded":
		fallthrough
	case "failed":
		fallthrough
	case "skipped":
		fallthrough
	case "canceled":
		*e = ChecksConclusion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChecksConclusion: %v", v)
	}
}

// ReadySubstate - Since June 2023 Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - PROMOTED: has seen production traffic
type ReadySubstate string

const (
	ReadySubstateStaged   ReadySubstate = "STAGED"
	ReadySubstatePromoted ReadySubstate = "PROMOTED"
)

func (e ReadySubstate) ToPointer() *ReadySubstate {
	return &e
}
func (e *ReadySubstate) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STAGED":
		fallthrough
	case "PROMOTED":
		*e = ReadySubstate(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReadySubstate: %v", v)
	}
}

type OidcTokenClaims struct {
	Iss         string `json:"iss"`
	Sub         string `json:"sub"`
	Scope       string `json:"scope"`
	Aud         string `json:"aud"`
	Owner       string `json:"owner"`
	OwnerID     string `json:"owner_id"`
	Project     string `json:"project"`
	ProjectID   string `json:"project_id"`
	Environment string `json:"environment"`
}

func (o *OidcTokenClaims) GetIss() string {
	if o == nil {
		return ""
	}
	return o.Iss
}

func (o *OidcTokenClaims) GetSub() string {
	if o == nil {
		return ""
	}
	return o.Sub
}

func (o *OidcTokenClaims) GetScope() string {
	if o == nil {
		return ""
	}
	return o.Scope
}

func (o *OidcTokenClaims) GetAud() string {
	if o == nil {
		return ""
	}
	return o.Aud
}

func (o *OidcTokenClaims) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *OidcTokenClaims) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *OidcTokenClaims) GetProject() string {
	if o == nil {
		return ""
	}
	return o.Project
}

func (o *OidcTokenClaims) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *OidcTokenClaims) GetEnvironment() string {
	if o == nil {
		return ""
	}
	return o.Environment
}

// Applications - A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment.
type Applications struct {
	// This is the production alias, it will always show the most up to date of each application.
	ProductionHost string `json:"productionHost"`
	// Use the fixed deploymentAlias and deploymentHost so that the microfrontend preview stays in sync with the deployment. These are only present for mono-repos when a single commit creates multiple deployments. If they are not present, productionHost will be used.
	DeploymentAlias *string `json:"deploymentAlias,omitempty"`
	DeploymentHost  *string `json:"deploymentHost,omitempty"`
}

func (o *Applications) GetProductionHost() string {
	if o == nil {
		return ""
	}
	return o.ProductionHost
}

func (o *Applications) GetDeploymentAlias() *string {
	if o == nil {
		return nil
	}
	return o.DeploymentAlias
}

func (o *Applications) GetDeploymentHost() *string {
	if o == nil {
		return nil
	}
	return o.DeploymentHost
}

type Microfrontends2 struct {
	// A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment.
	Applications map[string]Applications `json:"applications,omitempty"`
	IsDefaultApp bool                    `json:"isDefaultApp"`
	// A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
	DefaultRoute *string `json:"defaultRoute,omitempty"`
	// The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
	GroupIds []string `json:"groupIds"`
}

func (o *Microfrontends2) GetApplications() map[string]Applications {
	if o == nil {
		return nil
	}
	return o.Applications
}

func (o *Microfrontends2) GetIsDefaultApp() bool {
	if o == nil {
		return false
	}
	return o.IsDefaultApp
}

func (o *Microfrontends2) GetDefaultRoute() *string {
	if o == nil {
		return nil
	}
	return o.DefaultRoute
}

func (o *Microfrontends2) GetGroupIds() []string {
	if o == nil {
		return []string{}
	}
	return o.GroupIds
}

type Microfrontends1 struct {
	// Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.
	IsDefaultApp *bool `json:"isDefaultApp,omitempty"`
	// A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
	DefaultRoute *string `json:"defaultRoute,omitempty"`
	// The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
	GroupIds []string `json:"groupIds"`
}

func (o *Microfrontends1) GetIsDefaultApp() *bool {
	if o == nil {
		return nil
	}
	return o.IsDefaultApp
}

func (o *Microfrontends1) GetDefaultRoute() *string {
	if o == nil {
		return nil
	}
	return o.DefaultRoute
}

func (o *Microfrontends1) GetGroupIds() []string {
	if o == nil {
		return []string{}
	}
	return o.GroupIds
}

type CreateDeploymentMicrofrontendsType string

const (
	CreateDeploymentMicrofrontendsTypeMicrofrontends1 CreateDeploymentMicrofrontendsType = "microfrontends_1"
	CreateDeploymentMicrofrontendsTypeMicrofrontends2 CreateDeploymentMicrofrontendsType = "microfrontends_2"
)

type CreateDeploymentMicrofrontends struct {
	Microfrontends1 *Microfrontends1
	Microfrontends2 *Microfrontends2

	Type CreateDeploymentMicrofrontendsType
}

func CreateCreateDeploymentMicrofrontendsMicrofrontends1(microfrontends1 Microfrontends1) CreateDeploymentMicrofrontends {
	typ := CreateDeploymentMicrofrontendsTypeMicrofrontends1

	return CreateDeploymentMicrofrontends{
		Microfrontends1: &microfrontends1,
		Type:            typ,
	}
}

func CreateCreateDeploymentMicrofrontendsMicrofrontends2(microfrontends2 Microfrontends2) CreateDeploymentMicrofrontends {
	typ := CreateDeploymentMicrofrontendsTypeMicrofrontends2

	return CreateDeploymentMicrofrontends{
		Microfrontends2: &microfrontends2,
		Type:            typ,
	}
}

func (u *CreateDeploymentMicrofrontends) UnmarshalJSON(data []byte) error {

	var microfrontends1 Microfrontends1 = Microfrontends1{}
	if err := utils.UnmarshalJSON(data, &microfrontends1, "", true, true); err == nil {
		u.Microfrontends1 = &microfrontends1
		u.Type = CreateDeploymentMicrofrontendsTypeMicrofrontends1
		return nil
	}

	var microfrontends2 Microfrontends2 = Microfrontends2{}
	if err := utils.UnmarshalJSON(data, &microfrontends2, "", true, true); err == nil {
		u.Microfrontends2 = &microfrontends2
		u.Type = CreateDeploymentMicrofrontendsTypeMicrofrontends2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentMicrofrontends", string(data))
}

func (u CreateDeploymentMicrofrontends) MarshalJSON() ([]byte, error) {
	if u.Microfrontends1 != nil {
		return utils.MarshalJSON(u.Microfrontends1, "", true)
	}

	if u.Microfrontends2 != nil {
		return utils.MarshalJSON(u.Microfrontends2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentMicrofrontends: all fields are null")
}

type Functions struct {
	Memory       *float64 `json:"memory,omitempty"`
	MaxDuration  *float64 `json:"maxDuration,omitempty"`
	Runtime      *string  `json:"runtime,omitempty"`
	IncludeFiles *string  `json:"includeFiles,omitempty"`
	ExcludeFiles *string  `json:"excludeFiles,omitempty"`
}

func (o *Functions) GetMemory() *float64 {
	if o == nil {
		return nil
	}
	return o.Memory
}

func (o *Functions) GetMaxDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxDuration
}

func (o *Functions) GetRuntime() *string {
	if o == nil {
		return nil
	}
	return o.Runtime
}

func (o *Functions) GetIncludeFiles() *string {
	if o == nil {
		return nil
	}
	return o.IncludeFiles
}

func (o *Functions) GetExcludeFiles() *string {
	if o == nil {
		return nil
	}
	return o.ExcludeFiles
}

type Routes3 struct {
	Src        string  `json:"src"`
	Continue   bool    `json:"continue"`
	Middleware float64 `json:"middleware"`
}

func (o *Routes3) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *Routes3) GetContinue() bool {
	if o == nil {
		return false
	}
	return o.Continue
}

func (o *Routes3) GetMiddleware() float64 {
	if o == nil {
		return 0.0
	}
	return o.Middleware
}

type RoutesHandle string

const (
	RoutesHandleError      RoutesHandle = "error"
	RoutesHandleFilesystem RoutesHandle = "filesystem"
	RoutesHandleHit        RoutesHandle = "hit"
	RoutesHandleMiss       RoutesHandle = "miss"
	RoutesHandleRewrite    RoutesHandle = "rewrite"
	RoutesHandleResource   RoutesHandle = "resource"
)

func (e RoutesHandle) ToPointer() *RoutesHandle {
	return &e
}
func (e *RoutesHandle) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "error":
		fallthrough
	case "filesystem":
		fallthrough
	case "hit":
		fallthrough
	case "miss":
		fallthrough
	case "rewrite":
		fallthrough
	case "resource":
		*e = RoutesHandle(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RoutesHandle: %v", v)
	}
}

type Routes2 struct {
	Handle RoutesHandle `json:"handle"`
	Src    *string      `json:"src,omitempty"`
	Dest   *string      `json:"dest,omitempty"`
	Status *float64     `json:"status,omitempty"`
}

func (o *Routes2) GetHandle() RoutesHandle {
	if o == nil {
		return RoutesHandle("")
	}
	return o.Handle
}

func (o *Routes2) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *Routes2) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *Routes2) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

type CreateDeploymentHasType string

const (
	CreateDeploymentHasTypeHeader CreateDeploymentHasType = "header"
	CreateDeploymentHasTypeCookie CreateDeploymentHasType = "cookie"
	CreateDeploymentHasTypeQuery  CreateDeploymentHasType = "query"
)

func (e CreateDeploymentHasType) ToPointer() *CreateDeploymentHasType {
	return &e
}
func (e *CreateDeploymentHasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "query":
		*e = CreateDeploymentHasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentHasType: %v", v)
	}
}

type Has2 struct {
	Type  CreateDeploymentHasType `json:"type"`
	Key   string                  `json:"key"`
	Value *string                 `json:"value,omitempty"`
}

func (o *Has2) GetType() CreateDeploymentHasType {
	if o == nil {
		return CreateDeploymentHasType("")
	}
	return o.Type
}

func (o *Has2) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *Has2) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

type HasType string

const (
	HasTypeHost HasType = "host"
)

func (e HasType) ToPointer() *HasType {
	return &e
}
func (e *HasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = HasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HasType: %v", v)
	}
}

type Has1 struct {
	Type  HasType `json:"type"`
	Value string  `json:"value"`
}

func (o *Has1) GetType() HasType {
	if o == nil {
		return HasType("")
	}
	return o.Type
}

func (o *Has1) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type RoutesHasType string

const (
	RoutesHasTypeHas1 RoutesHasType = "has_1"
	RoutesHasTypeHas2 RoutesHasType = "has_2"
)

type RoutesHas struct {
	Has1 *Has1
	Has2 *Has2

	Type RoutesHasType
}

func CreateRoutesHasHas1(has1 Has1) RoutesHas {
	typ := RoutesHasTypeHas1

	return RoutesHas{
		Has1: &has1,
		Type: typ,
	}
}

func CreateRoutesHasHas2(has2 Has2) RoutesHas {
	typ := RoutesHasTypeHas2

	return RoutesHas{
		Has2: &has2,
		Type: typ,
	}
}

func (u *RoutesHas) UnmarshalJSON(data []byte) error {

	var has1 Has1 = Has1{}
	if err := utils.UnmarshalJSON(data, &has1, "", true, true); err == nil {
		u.Has1 = &has1
		u.Type = RoutesHasTypeHas1
		return nil
	}

	var has2 Has2 = Has2{}
	if err := utils.UnmarshalJSON(data, &has2, "", true, true); err == nil {
		u.Has2 = &has2
		u.Type = RoutesHasTypeHas2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RoutesHas", string(data))
}

func (u RoutesHas) MarshalJSON() ([]byte, error) {
	if u.Has1 != nil {
		return utils.MarshalJSON(u.Has1, "", true)
	}

	if u.Has2 != nil {
		return utils.MarshalJSON(u.Has2, "", true)
	}

	return nil, errors.New("could not marshal union type RoutesHas: all fields are null")
}

type CreateDeploymentMissingType string

const (
	CreateDeploymentMissingTypeHeader CreateDeploymentMissingType = "header"
	CreateDeploymentMissingTypeCookie CreateDeploymentMissingType = "cookie"
	CreateDeploymentMissingTypeQuery  CreateDeploymentMissingType = "query"
)

func (e CreateDeploymentMissingType) ToPointer() *CreateDeploymentMissingType {
	return &e
}
func (e *CreateDeploymentMissingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "query":
		*e = CreateDeploymentMissingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentMissingType: %v", v)
	}
}

type Missing2 struct {
	Type  CreateDeploymentMissingType `json:"type"`
	Key   string                      `json:"key"`
	Value *string                     `json:"value,omitempty"`
}

func (o *Missing2) GetType() CreateDeploymentMissingType {
	if o == nil {
		return CreateDeploymentMissingType("")
	}
	return o.Type
}

func (o *Missing2) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *Missing2) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

type MissingType string

const (
	MissingTypeHost MissingType = "host"
)

func (e MissingType) ToPointer() *MissingType {
	return &e
}
func (e *MissingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = MissingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MissingType: %v", v)
	}
}

type Missing1 struct {
	Type  MissingType `json:"type"`
	Value string      `json:"value"`
}

func (o *Missing1) GetType() MissingType {
	if o == nil {
		return MissingType("")
	}
	return o.Type
}

func (o *Missing1) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type RoutesMissingType string

const (
	RoutesMissingTypeMissing1 RoutesMissingType = "missing_1"
	RoutesMissingTypeMissing2 RoutesMissingType = "missing_2"
)

type RoutesMissing struct {
	Missing1 *Missing1
	Missing2 *Missing2

	Type RoutesMissingType
}

func CreateRoutesMissingMissing1(missing1 Missing1) RoutesMissing {
	typ := RoutesMissingTypeMissing1

	return RoutesMissing{
		Missing1: &missing1,
		Type:     typ,
	}
}

func CreateRoutesMissingMissing2(missing2 Missing2) RoutesMissing {
	typ := RoutesMissingTypeMissing2

	return RoutesMissing{
		Missing2: &missing2,
		Type:     typ,
	}
}

func (u *RoutesMissing) UnmarshalJSON(data []byte) error {

	var missing1 Missing1 = Missing1{}
	if err := utils.UnmarshalJSON(data, &missing1, "", true, true); err == nil {
		u.Missing1 = &missing1
		u.Type = RoutesMissingTypeMissing1
		return nil
	}

	var missing2 Missing2 = Missing2{}
	if err := utils.UnmarshalJSON(data, &missing2, "", true, true); err == nil {
		u.Missing2 = &missing2
		u.Type = RoutesMissingTypeMissing2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RoutesMissing", string(data))
}

func (u RoutesMissing) MarshalJSON() ([]byte, error) {
	if u.Missing1 != nil {
		return utils.MarshalJSON(u.Missing1, "", true)
	}

	if u.Missing2 != nil {
		return utils.MarshalJSON(u.Missing2, "", true)
	}

	return nil, errors.New("could not marshal union type RoutesMissing: all fields are null")
}

type Locale struct {
	Redirect map[string]string `json:"redirect,omitempty"`
	Cookie   *string           `json:"cookie,omitempty"`
}

func (o *Locale) GetRedirect() map[string]string {
	if o == nil {
		return nil
	}
	return o.Redirect
}

func (o *Locale) GetCookie() *string {
	if o == nil {
		return nil
	}
	return o.Cookie
}

type Routes1 struct {
	Src           string            `json:"src"`
	Dest          *string           `json:"dest,omitempty"`
	Headers       map[string]string `json:"headers,omitempty"`
	Methods       []string          `json:"methods,omitempty"`
	Continue      *bool             `json:"continue,omitempty"`
	Override      *bool             `json:"override,omitempty"`
	CaseSensitive *bool             `json:"caseSensitive,omitempty"`
	Check         *bool             `json:"check,omitempty"`
	Important     *bool             `json:"important,omitempty"`
	Status        *float64          `json:"status,omitempty"`
	Has           []RoutesHas       `json:"has,omitempty"`
	Missing       []RoutesMissing   `json:"missing,omitempty"`
	Locale        *Locale           `json:"locale,omitempty"`
	// A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
	MiddlewarePath *string `json:"middlewarePath,omitempty"`
	// The original middleware matchers.
	MiddlewareRawSrc []string `json:"middlewareRawSrc,omitempty"`
	// A middleware index in the `middleware` key under the build result
	Middleware *float64 `json:"middleware,omitempty"`
}

func (o *Routes1) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *Routes1) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *Routes1) GetHeaders() map[string]string {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *Routes1) GetMethods() []string {
	if o == nil {
		return nil
	}
	return o.Methods
}

func (o *Routes1) GetContinue() *bool {
	if o == nil {
		return nil
	}
	return o.Continue
}

func (o *Routes1) GetOverride() *bool {
	if o == nil {
		return nil
	}
	return o.Override
}

func (o *Routes1) GetCaseSensitive() *bool {
	if o == nil {
		return nil
	}
	return o.CaseSensitive
}

func (o *Routes1) GetCheck() *bool {
	if o == nil {
		return nil
	}
	return o.Check
}

func (o *Routes1) GetImportant() *bool {
	if o == nil {
		return nil
	}
	return o.Important
}

func (o *Routes1) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Routes1) GetHas() []RoutesHas {
	if o == nil {
		return nil
	}
	return o.Has
}

func (o *Routes1) GetMissing() []RoutesMissing {
	if o == nil {
		return nil
	}
	return o.Missing
}

func (o *Routes1) GetLocale() *Locale {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *Routes1) GetMiddlewarePath() *string {
	if o == nil {
		return nil
	}
	return o.MiddlewarePath
}

func (o *Routes1) GetMiddlewareRawSrc() []string {
	if o == nil {
		return nil
	}
	return o.MiddlewareRawSrc
}

func (o *Routes1) GetMiddleware() *float64 {
	if o == nil {
		return nil
	}
	return o.Middleware
}

type RoutesType string

const (
	RoutesTypeRoutes1 RoutesType = "routes_1"
	RoutesTypeRoutes2 RoutesType = "routes_2"
	RoutesTypeRoutes3 RoutesType = "routes_3"
)

type Routes struct {
	Routes1 *Routes1
	Routes2 *Routes2
	Routes3 *Routes3

	Type RoutesType
}

func CreateRoutesRoutes1(routes1 Routes1) Routes {
	typ := RoutesTypeRoutes1

	return Routes{
		Routes1: &routes1,
		Type:    typ,
	}
}

func CreateRoutesRoutes2(routes2 Routes2) Routes {
	typ := RoutesTypeRoutes2

	return Routes{
		Routes2: &routes2,
		Type:    typ,
	}
}

func CreateRoutesRoutes3(routes3 Routes3) Routes {
	typ := RoutesTypeRoutes3

	return Routes{
		Routes3: &routes3,
		Type:    typ,
	}
}

func (u *Routes) UnmarshalJSON(data []byte) error {

	var routes3 Routes3 = Routes3{}
	if err := utils.UnmarshalJSON(data, &routes3, "", true, true); err == nil {
		u.Routes3 = &routes3
		u.Type = RoutesTypeRoutes3
		return nil
	}

	var routes2 Routes2 = Routes2{}
	if err := utils.UnmarshalJSON(data, &routes2, "", true, true); err == nil {
		u.Routes2 = &routes2
		u.Type = RoutesTypeRoutes2
		return nil
	}

	var routes1 Routes1 = Routes1{}
	if err := utils.UnmarshalJSON(data, &routes1, "", true, true); err == nil {
		u.Routes1 = &routes1
		u.Type = RoutesTypeRoutes1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Routes", string(data))
}

func (u Routes) MarshalJSON() ([]byte, error) {
	if u.Routes1 != nil {
		return utils.MarshalJSON(u.Routes1, "", true)
	}

	if u.Routes2 != nil {
		return utils.MarshalJSON(u.Routes2, "", true)
	}

	if u.Routes3 != nil {
		return utils.MarshalJSON(u.Routes3, "", true)
	}

	return nil, errors.New("could not marshal union type Routes: all fields are null")
}

type CreateDeploymentCrons struct {
	Schedule string `json:"schedule"`
	Path     string `json:"path"`
}

func (o *CreateDeploymentCrons) GetSchedule() string {
	if o == nil {
		return ""
	}
	return o.Schedule
}

func (o *CreateDeploymentCrons) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

type Plan string

const (
	PlanPro        Plan = "pro"
	PlanEnterprise Plan = "enterprise"
	PlanHobby      Plan = "hobby"
)

func (e Plan) ToPointer() *Plan {
	return &e
}
func (e *Plan) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pro":
		fallthrough
	case "enterprise":
		fallthrough
	case "hobby":
		*e = Plan(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Plan: %v", v)
	}
}

type CreateDeploymentGitRepoDeploymentsType string

const (
	CreateDeploymentGitRepoDeploymentsTypeBitbucket CreateDeploymentGitRepoDeploymentsType = "bitbucket"
)

func (e CreateDeploymentGitRepoDeploymentsType) ToPointer() *CreateDeploymentGitRepoDeploymentsType {
	return &e
}
func (e *CreateDeploymentGitRepoDeploymentsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitRepoDeploymentsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoDeploymentsType: %v", v)
	}
}

type CreateDeploymentGitRepoOwnerType string

const (
	CreateDeploymentGitRepoOwnerTypeTeam CreateDeploymentGitRepoOwnerType = "team"
	CreateDeploymentGitRepoOwnerTypeUser CreateDeploymentGitRepoOwnerType = "user"
)

func (e CreateDeploymentGitRepoOwnerType) ToPointer() *CreateDeploymentGitRepoOwnerType {
	return &e
}
func (e *CreateDeploymentGitRepoOwnerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "user":
		*e = CreateDeploymentGitRepoOwnerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoOwnerType: %v", v)
	}
}

type GitRepo3 struct {
	Owner         string                                 `json:"owner"`
	RepoUUID      string                                 `json:"repoUuid"`
	Slug          string                                 `json:"slug"`
	Type          CreateDeploymentGitRepoDeploymentsType `json:"type"`
	WorkspaceUUID string                                 `json:"workspaceUuid"`
	Path          string                                 `json:"path"`
	DefaultBranch string                                 `json:"defaultBranch"`
	Name          string                                 `json:"name"`
	Private       bool                                   `json:"private"`
	OwnerType     CreateDeploymentGitRepoOwnerType       `json:"ownerType"`
}

func (o *GitRepo3) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *GitRepo3) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *GitRepo3) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GitRepo3) GetType() CreateDeploymentGitRepoDeploymentsType {
	if o == nil {
		return CreateDeploymentGitRepoDeploymentsType("")
	}
	return o.Type
}

func (o *GitRepo3) GetWorkspaceUUID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceUUID
}

func (o *GitRepo3) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *GitRepo3) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *GitRepo3) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GitRepo3) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GitRepo3) GetOwnerType() CreateDeploymentGitRepoOwnerType {
	if o == nil {
		return CreateDeploymentGitRepoOwnerType("")
	}
	return o.OwnerType
}

type CreateDeploymentGitRepoType string

const (
	CreateDeploymentGitRepoTypeGithub CreateDeploymentGitRepoType = "github"
)

func (e CreateDeploymentGitRepoType) ToPointer() *CreateDeploymentGitRepoType {
	return &e
}
func (e *CreateDeploymentGitRepoType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitRepoType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoType: %v", v)
	}
}

type GitRepoOwnerType string

const (
	GitRepoOwnerTypeTeam GitRepoOwnerType = "team"
	GitRepoOwnerTypeUser GitRepoOwnerType = "user"
)

func (e GitRepoOwnerType) ToPointer() *GitRepoOwnerType {
	return &e
}
func (e *GitRepoOwnerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "user":
		*e = GitRepoOwnerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GitRepoOwnerType: %v", v)
	}
}

type GitRepo2 struct {
	Org           string                      `json:"org"`
	Repo          string                      `json:"repo"`
	RepoID        float64                     `json:"repoId"`
	Type          CreateDeploymentGitRepoType `json:"type"`
	RepoOwnerID   float64                     `json:"repoOwnerId"`
	Path          string                      `json:"path"`
	DefaultBranch string                      `json:"defaultBranch"`
	Name          string                      `json:"name"`
	Private       bool                        `json:"private"`
	OwnerType     GitRepoOwnerType            `json:"ownerType"`
}

func (o *GitRepo2) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GitRepo2) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *GitRepo2) GetRepoID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoID
}

func (o *GitRepo2) GetType() CreateDeploymentGitRepoType {
	if o == nil {
		return CreateDeploymentGitRepoType("")
	}
	return o.Type
}

func (o *GitRepo2) GetRepoOwnerID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoOwnerID
}

func (o *GitRepo2) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *GitRepo2) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *GitRepo2) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GitRepo2) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GitRepo2) GetOwnerType() GitRepoOwnerType {
	if o == nil {
		return GitRepoOwnerType("")
	}
	return o.OwnerType
}

type GitRepoType string

const (
	GitRepoTypeGitlab GitRepoType = "gitlab"
)

func (e GitRepoType) ToPointer() *GitRepoType {
	return &e
}
func (e *GitRepoType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = GitRepoType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GitRepoType: %v", v)
	}
}

type OwnerType string

const (
	OwnerTypeTeam OwnerType = "team"
	OwnerTypeUser OwnerType = "user"
)

func (e OwnerType) ToPointer() *OwnerType {
	return &e
}
func (e *OwnerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "user":
		*e = OwnerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OwnerType: %v", v)
	}
}

type GitRepo1 struct {
	Namespace     string      `json:"namespace"`
	ProjectID     float64     `json:"projectId"`
	Type          GitRepoType `json:"type"`
	URL           string      `json:"url"`
	Path          string      `json:"path"`
	DefaultBranch string      `json:"defaultBranch"`
	Name          string      `json:"name"`
	Private       bool        `json:"private"`
	OwnerType     OwnerType   `json:"ownerType"`
}

func (o *GitRepo1) GetNamespace() string {
	if o == nil {
		return ""
	}
	return o.Namespace
}

func (o *GitRepo1) GetProjectID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ProjectID
}

func (o *GitRepo1) GetType() GitRepoType {
	if o == nil {
		return GitRepoType("")
	}
	return o.Type
}

func (o *GitRepo1) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *GitRepo1) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *GitRepo1) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *GitRepo1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GitRepo1) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GitRepo1) GetOwnerType() OwnerType {
	if o == nil {
		return OwnerType("")
	}
	return o.OwnerType
}

type GitRepoUnionType string

const (
	GitRepoUnionTypeGitRepo1 GitRepoUnionType = "gitRepo_1"
	GitRepoUnionTypeGitRepo2 GitRepoUnionType = "gitRepo_2"
	GitRepoUnionTypeGitRepo3 GitRepoUnionType = "gitRepo_3"
)

type GitRepo struct {
	GitRepo1 *GitRepo1
	GitRepo2 *GitRepo2
	GitRepo3 *GitRepo3

	Type GitRepoUnionType
}

func CreateGitRepoGitRepo1(gitRepo1 GitRepo1) GitRepo {
	typ := GitRepoUnionTypeGitRepo1

	return GitRepo{
		GitRepo1: &gitRepo1,
		Type:     typ,
	}
}

func CreateGitRepoGitRepo2(gitRepo2 GitRepo2) GitRepo {
	typ := GitRepoUnionTypeGitRepo2

	return GitRepo{
		GitRepo2: &gitRepo2,
		Type:     typ,
	}
}

func CreateGitRepoGitRepo3(gitRepo3 GitRepo3) GitRepo {
	typ := GitRepoUnionTypeGitRepo3

	return GitRepo{
		GitRepo3: &gitRepo3,
		Type:     typ,
	}
}

func (u *GitRepo) UnmarshalJSON(data []byte) error {

	var gitRepo1 GitRepo1 = GitRepo1{}
	if err := utils.UnmarshalJSON(data, &gitRepo1, "", true, true); err == nil {
		u.GitRepo1 = &gitRepo1
		u.Type = GitRepoUnionTypeGitRepo1
		return nil
	}

	var gitRepo2 GitRepo2 = GitRepo2{}
	if err := utils.UnmarshalJSON(data, &gitRepo2, "", true, true); err == nil {
		u.GitRepo2 = &gitRepo2
		u.Type = GitRepoUnionTypeGitRepo2
		return nil
	}

	var gitRepo3 GitRepo3 = GitRepo3{}
	if err := utils.UnmarshalJSON(data, &gitRepo3, "", true, true); err == nil {
		u.GitRepo3 = &gitRepo3
		u.Type = GitRepoUnionTypeGitRepo3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitRepo", string(data))
}

func (u GitRepo) MarshalJSON() ([]byte, error) {
	if u.GitRepo1 != nil {
		return utils.MarshalJSON(u.GitRepo1, "", true)
	}

	if u.GitRepo2 != nil {
		return utils.MarshalJSON(u.GitRepo2, "", true)
	}

	if u.GitRepo3 != nil {
		return utils.MarshalJSON(u.GitRepo3, "", true)
	}

	return nil, errors.New("could not marshal union type GitRepo: all fields are null")
}

// Flags2 - Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
type Flags2 struct {
}

type Options struct {
	Value *components.FlagJSONValue `json:"value"`
	Label *string                   `json:"label,omitempty"`
}

func (o *Options) GetValue() *components.FlagJSONValue {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *Options) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

type FlagsDefinitions struct {
	Options     []Options `json:"options,omitempty"`
	URL         *string   `json:"url,omitempty"`
	Description *string   `json:"description,omitempty"`
}

func (o *FlagsDefinitions) GetOptions() []Options {
	if o == nil {
		return nil
	}
	return o.Options
}

func (o *FlagsDefinitions) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

func (o *FlagsDefinitions) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

// Flags1 - Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
type Flags1 struct {
	Definitions map[string]FlagsDefinitions `json:"definitions"`
}

func (o *Flags1) GetDefinitions() map[string]FlagsDefinitions {
	if o == nil {
		return map[string]FlagsDefinitions{}
	}
	return o.Definitions
}

type FlagsType string

const (
	FlagsTypeFlags1        FlagsType = "flags_1"
	FlagsTypeArrayOfFlags2 FlagsType = "arrayOfFlags2"
)

type Flags struct {
	Flags1        *Flags1
	ArrayOfFlags2 []Flags2

	Type FlagsType
}

func CreateFlagsFlags1(flags1 Flags1) Flags {
	typ := FlagsTypeFlags1

	return Flags{
		Flags1: &flags1,
		Type:   typ,
	}
}

func CreateFlagsArrayOfFlags2(arrayOfFlags2 []Flags2) Flags {
	typ := FlagsTypeArrayOfFlags2

	return Flags{
		ArrayOfFlags2: arrayOfFlags2,
		Type:          typ,
	}
}

func (u *Flags) UnmarshalJSON(data []byte) error {

	var flags1 Flags1 = Flags1{}
	if err := utils.UnmarshalJSON(data, &flags1, "", true, true); err == nil {
		u.Flags1 = &flags1
		u.Type = FlagsTypeFlags1
		return nil
	}

	var arrayOfFlags2 []Flags2 = []Flags2{}
	if err := utils.UnmarshalJSON(data, &arrayOfFlags2, "", true, true); err == nil {
		u.ArrayOfFlags2 = arrayOfFlags2
		u.Type = FlagsTypeArrayOfFlags2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Flags", string(data))
}

func (u Flags) MarshalJSON() ([]byte, error) {
	if u.Flags1 != nil {
		return utils.MarshalJSON(u.Flags1, "", true)
	}

	if u.ArrayOfFlags2 != nil {
		return utils.MarshalJSON(u.ArrayOfFlags2, "", true)
	}

	return nil, errors.New("could not marshal union type Flags: all fields are null")
}

// CreateDeploymentResponseBody - The successfully created deployment
type CreateDeploymentResponseBody struct {
	AliasAssignedAt           *AliasAssignedAt                `json:"aliasAssignedAt,omitempty"`
	AlwaysRefuseToBuild       *bool                           `json:"alwaysRefuseToBuild,omitempty"`
	Build                     Build                           `json:"build"`
	BuildArtifactUrls         []string                        `json:"buildArtifactUrls,omitempty"`
	Builds                    []Builds                        `json:"builds,omitempty"`
	Env                       []string                        `json:"env"`
	InspectorURL              *string                         `json:"inspectorUrl"`
	IsInConcurrentBuildsQueue bool                            `json:"isInConcurrentBuildsQueue"`
	IsInSystemBuildsQueue     bool                            `json:"isInSystemBuildsQueue"`
	ProjectSettings           CreateDeploymentProjectSettings `json:"projectSettings"`
	ReadyStateReason          *string                         `json:"readyStateReason,omitempty"`
	Integrations              *Integrations                   `json:"integrations,omitempty"`
	Images                    *Images                         `json:"images,omitempty"`
	Alias                     []string                        `json:"alias,omitempty"`
	AliasAssigned             bool                            `json:"aliasAssigned"`
	BootedAt                  float64                         `json:"bootedAt"`
	BuildingAt                float64                         `json:"buildingAt"`
	BuildSkipped              bool                            `json:"buildSkipped"`
	Creator                   Creator                         `json:"creator"`
	InitReadyAt               *float64                        `json:"initReadyAt,omitempty"`
	IsFirstBranchDeployment   *bool                           `json:"isFirstBranchDeployment,omitempty"`
	Lambdas                   []Lambdas                       `json:"lambdas,omitempty"`
	Public                    bool                            `json:"public"`
	Ready                     *float64                        `json:"ready,omitempty"`
	Status                    CreateDeploymentStatus          `json:"status"`
	Team                      *Team                           `json:"team,omitempty"`
	UserAliases               []string                        `json:"userAliases,omitempty"`
	PreviewCommentsEnabled    *bool                           `json:"previewCommentsEnabled,omitempty"`
	TtyBuildLogs              *bool                           `json:"ttyBuildLogs,omitempty"`
	CustomEnvironment         *CustomEnvironment              `json:"customEnvironment,omitempty"`
	Type                      CreateDeploymentType            `json:"type"`
	CreatedAt                 float64                         `json:"createdAt"`
	Name                      string                          `json:"name"`
	DeletedAt                 *float64                        `json:"deletedAt,omitempty"`
	ID                        string                          `json:"id"`
	Version                   float64                         `json:"version"`
	// applies to custom domains only, defaults to `true`
	AutoAssignCustomDomains *bool                      `json:"autoAssignCustomDomains,omitempty"`
	GitSource               *CreateDeploymentGitSource `json:"gitSource,omitempty"`
	Meta                    map[string]string          `json:"meta"`
	Project                 *Project                   `json:"project,omitempty"`
	ReadyState              ReadyState                 `json:"readyState"`
	Source                  *CreateDeploymentSource    `json:"source,omitempty"`
	Target                  *CreateDeploymentTarget    `json:"target,omitempty"`
	// Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service
	PassiveRegions   []string          `json:"passiveRegions,omitempty"`
	Regions          []string          `json:"regions"`
	ErrorMessage     *string           `json:"errorMessage,omitempty"`
	AliasWarning     *AliasWarning     `json:"aliasWarning,omitempty"`
	AliasError       *AliasError       `json:"aliasError,omitempty"`
	AliasFinal       *string           `json:"aliasFinal,omitempty"`
	AutomaticAliases []string          `json:"automaticAliases,omitempty"`
	BuildErrorAt     *float64          `json:"buildErrorAt,omitempty"`
	ChecksState      *ChecksState      `json:"checksState,omitempty"`
	ChecksConclusion *ChecksConclusion `json:"checksConclusion,omitempty"`
	// Computed field that is only available for deployments with a microfrontend configuration.
	DefaultRoute      *string  `json:"defaultRoute,omitempty"`
	CanceledAt        *float64 `json:"canceledAt,omitempty"`
	ErrorCode         *string  `json:"errorCode,omitempty"`
	ErrorLink         *string  `json:"errorLink,omitempty"`
	ErrorStep         *string  `json:"errorStep,omitempty"`
	OriginCacheRegion *string  `json:"originCacheRegion,omitempty"`
	// Since June 2023 Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - PROMOTED: has seen production traffic
	ReadySubstate          *ReadySubstate                  `json:"readySubstate,omitempty"`
	SoftDeletedByRetention *bool                           `json:"softDeletedByRetention,omitempty"`
	UndeletedAt            *float64                        `json:"undeletedAt,omitempty"`
	URL                    string                          `json:"url"`
	OidcTokenClaims        *OidcTokenClaims                `json:"oidcTokenClaims,omitempty"`
	ProjectID              string                          `json:"projectId"`
	OwnerID                string                          `json:"ownerId"`
	Microfrontends         *CreateDeploymentMicrofrontends `json:"microfrontends,omitempty"`
	MonorepoManager        *string                         `json:"monorepoManager,omitempty"`
	Functions              map[string]Functions            `json:"functions,omitempty"`
	Routes                 []Routes                        `json:"routes"`
	Crons                  []CreateDeploymentCrons         `json:"crons,omitempty"`
	Plan                   Plan                            `json:"plan"`
	ConnectBuildsEnabled   *bool                           `json:"connectBuildsEnabled,omitempty"`
	ConnectConfigurationID *string                         `json:"connectConfigurationId,omitempty"`
	CreatedIn              string                          `json:"createdIn"`
	// Since November 2023 this field defines a Secure Compute network that will only be used to deploy passive lambdas to (as in passiveRegions)
	PassiveConnectConfigurationID *string  `json:"passiveConnectConfigurationId,omitempty"`
	GitRepo                       *GitRepo `json:"gitRepo,omitempty"`
	Flags                         *Flags   `json:"flags,omitempty"`
}

func (o *CreateDeploymentResponseBody) GetAliasAssignedAt() *AliasAssignedAt {
	if o == nil {
		return nil
	}
	return o.AliasAssignedAt
}

func (o *CreateDeploymentResponseBody) GetAlwaysRefuseToBuild() *bool {
	if o == nil {
		return nil
	}
	return o.AlwaysRefuseToBuild
}

func (o *CreateDeploymentResponseBody) GetBuild() Build {
	if o == nil {
		return Build{}
	}
	return o.Build
}

func (o *CreateDeploymentResponseBody) GetBuildArtifactUrls() []string {
	if o == nil {
		return nil
	}
	return o.BuildArtifactUrls
}

func (o *CreateDeploymentResponseBody) GetBuilds() []Builds {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *CreateDeploymentResponseBody) GetEnv() []string {
	if o == nil {
		return []string{}
	}
	return o.Env
}

func (o *CreateDeploymentResponseBody) GetInspectorURL() *string {
	if o == nil {
		return nil
	}
	return o.InspectorURL
}

func (o *CreateDeploymentResponseBody) GetIsInConcurrentBuildsQueue() bool {
	if o == nil {
		return false
	}
	return o.IsInConcurrentBuildsQueue
}

func (o *CreateDeploymentResponseBody) GetIsInSystemBuildsQueue() bool {
	if o == nil {
		return false
	}
	return o.IsInSystemBuildsQueue
}

func (o *CreateDeploymentResponseBody) GetProjectSettings() CreateDeploymentProjectSettings {
	if o == nil {
		return CreateDeploymentProjectSettings{}
	}
	return o.ProjectSettings
}

func (o *CreateDeploymentResponseBody) GetReadyStateReason() *string {
	if o == nil {
		return nil
	}
	return o.ReadyStateReason
}

func (o *CreateDeploymentResponseBody) GetIntegrations() *Integrations {
	if o == nil {
		return nil
	}
	return o.Integrations
}

func (o *CreateDeploymentResponseBody) GetImages() *Images {
	if o == nil {
		return nil
	}
	return o.Images
}

func (o *CreateDeploymentResponseBody) GetAlias() []string {
	if o == nil {
		return nil
	}
	return o.Alias
}

func (o *CreateDeploymentResponseBody) GetAliasAssigned() bool {
	if o == nil {
		return false
	}
	return o.AliasAssigned
}

func (o *CreateDeploymentResponseBody) GetBootedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.BootedAt
}

func (o *CreateDeploymentResponseBody) GetBuildingAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.BuildingAt
}

func (o *CreateDeploymentResponseBody) GetBuildSkipped() bool {
	if o == nil {
		return false
	}
	return o.BuildSkipped
}

func (o *CreateDeploymentResponseBody) GetCreator() Creator {
	if o == nil {
		return Creator{}
	}
	return o.Creator
}

func (o *CreateDeploymentResponseBody) GetInitReadyAt() *float64 {
	if o == nil {
		return nil
	}
	return o.InitReadyAt
}

func (o *CreateDeploymentResponseBody) GetIsFirstBranchDeployment() *bool {
	if o == nil {
		return nil
	}
	return o.IsFirstBranchDeployment
}

func (o *CreateDeploymentResponseBody) GetLambdas() []Lambdas {
	if o == nil {
		return nil
	}
	return o.Lambdas
}

func (o *CreateDeploymentResponseBody) GetPublic() bool {
	if o == nil {
		return false
	}
	return o.Public
}

func (o *CreateDeploymentResponseBody) GetReady() *float64 {
	if o == nil {
		return nil
	}
	return o.Ready
}

func (o *CreateDeploymentResponseBody) GetStatus() CreateDeploymentStatus {
	if o == nil {
		return CreateDeploymentStatus("")
	}
	return o.Status
}

func (o *CreateDeploymentResponseBody) GetTeam() *Team {
	if o == nil {
		return nil
	}
	return o.Team
}

func (o *CreateDeploymentResponseBody) GetUserAliases() []string {
	if o == nil {
		return nil
	}
	return o.UserAliases
}

func (o *CreateDeploymentResponseBody) GetPreviewCommentsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.PreviewCommentsEnabled
}

func (o *CreateDeploymentResponseBody) GetTtyBuildLogs() *bool {
	if o == nil {
		return nil
	}
	return o.TtyBuildLogs
}

func (o *CreateDeploymentResponseBody) GetCustomEnvironment() *CustomEnvironment {
	if o == nil {
		return nil
	}
	return o.CustomEnvironment
}

func (o *CreateDeploymentResponseBody) GetType() CreateDeploymentType {
	if o == nil {
		return CreateDeploymentType("")
	}
	return o.Type
}

func (o *CreateDeploymentResponseBody) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *CreateDeploymentResponseBody) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentResponseBody) GetDeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *CreateDeploymentResponseBody) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentResponseBody) GetVersion() float64 {
	if o == nil {
		return 0.0
	}
	return o.Version
}

func (o *CreateDeploymentResponseBody) GetAutoAssignCustomDomains() *bool {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomains
}

func (o *CreateDeploymentResponseBody) GetGitSource() *CreateDeploymentGitSource {
	if o == nil {
		return nil
	}
	return o.GitSource
}

func (o *CreateDeploymentResponseBody) GetMeta() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Meta
}

func (o *CreateDeploymentResponseBody) GetProject() *Project {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *CreateDeploymentResponseBody) GetReadyState() ReadyState {
	if o == nil {
		return ReadyState("")
	}
	return o.ReadyState
}

func (o *CreateDeploymentResponseBody) GetSource() *CreateDeploymentSource {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *CreateDeploymentResponseBody) GetTarget() *CreateDeploymentTarget {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *CreateDeploymentResponseBody) GetPassiveRegions() []string {
	if o == nil {
		return nil
	}
	return o.PassiveRegions
}

func (o *CreateDeploymentResponseBody) GetRegions() []string {
	if o == nil {
		return []string{}
	}
	return o.Regions
}

func (o *CreateDeploymentResponseBody) GetErrorMessage() *string {
	if o == nil {
		return nil
	}
	return o.ErrorMessage
}

func (o *CreateDeploymentResponseBody) GetAliasWarning() *AliasWarning {
	if o == nil {
		return nil
	}
	return o.AliasWarning
}

func (o *CreateDeploymentResponseBody) GetAliasError() *AliasError {
	if o == nil {
		return nil
	}
	return o.AliasError
}

func (o *CreateDeploymentResponseBody) GetAliasFinal() *string {
	if o == nil {
		return nil
	}
	return o.AliasFinal
}

func (o *CreateDeploymentResponseBody) GetAutomaticAliases() []string {
	if o == nil {
		return nil
	}
	return o.AutomaticAliases
}

func (o *CreateDeploymentResponseBody) GetBuildErrorAt() *float64 {
	if o == nil {
		return nil
	}
	return o.BuildErrorAt
}

func (o *CreateDeploymentResponseBody) GetChecksState() *ChecksState {
	if o == nil {
		return nil
	}
	return o.ChecksState
}

func (o *CreateDeploymentResponseBody) GetChecksConclusion() *ChecksConclusion {
	if o == nil {
		return nil
	}
	return o.ChecksConclusion
}

func (o *CreateDeploymentResponseBody) GetDefaultRoute() *string {
	if o == nil {
		return nil
	}
	return o.DefaultRoute
}

func (o *CreateDeploymentResponseBody) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *CreateDeploymentResponseBody) GetErrorCode() *string {
	if o == nil {
		return nil
	}
	return o.ErrorCode
}

func (o *CreateDeploymentResponseBody) GetErrorLink() *string {
	if o == nil {
		return nil
	}
	return o.ErrorLink
}

func (o *CreateDeploymentResponseBody) GetErrorStep() *string {
	if o == nil {
		return nil
	}
	return o.ErrorStep
}

func (o *CreateDeploymentResponseBody) GetOriginCacheRegion() *string {
	if o == nil {
		return nil
	}
	return o.OriginCacheRegion
}

func (o *CreateDeploymentResponseBody) GetReadySubstate() *ReadySubstate {
	if o == nil {
		return nil
	}
	return o.ReadySubstate
}

func (o *CreateDeploymentResponseBody) GetSoftDeletedByRetention() *bool {
	if o == nil {
		return nil
	}
	return o.SoftDeletedByRetention
}

func (o *CreateDeploymentResponseBody) GetUndeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UndeletedAt
}

func (o *CreateDeploymentResponseBody) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *CreateDeploymentResponseBody) GetOidcTokenClaims() *OidcTokenClaims {
	if o == nil {
		return nil
	}
	return o.OidcTokenClaims
}

func (o *CreateDeploymentResponseBody) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *CreateDeploymentResponseBody) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *CreateDeploymentResponseBody) GetMicrofrontends() *CreateDeploymentMicrofrontends {
	if o == nil {
		return nil
	}
	return o.Microfrontends
}

func (o *CreateDeploymentResponseBody) GetMonorepoManager() *string {
	if o == nil {
		return nil
	}
	return o.MonorepoManager
}

func (o *CreateDeploymentResponseBody) GetFunctions() map[string]Functions {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *CreateDeploymentResponseBody) GetRoutes() []Routes {
	if o == nil {
		return nil
	}
	return o.Routes
}

func (o *CreateDeploymentResponseBody) GetCrons() []CreateDeploymentCrons {
	if o == nil {
		return nil
	}
	return o.Crons
}

func (o *CreateDeploymentResponseBody) GetPlan() Plan {
	if o == nil {
		return Plan("")
	}
	return o.Plan
}

func (o *CreateDeploymentResponseBody) GetConnectBuildsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ConnectBuildsEnabled
}

func (o *CreateDeploymentResponseBody) GetConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.ConnectConfigurationID
}

func (o *CreateDeploymentResponseBody) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *CreateDeploymentResponseBody) GetPassiveConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.PassiveConnectConfigurationID
}

func (o *CreateDeploymentResponseBody) GetGitRepo() *GitRepo {
	if o == nil {
		return nil
	}
	return o.GitRepo
}

func (o *CreateDeploymentResponseBody) GetFlags() *Flags {
	if o == nil {
		return nil
	}
	return o.Flags
}

type CreateDeploymentResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// The successfully created deployment
	Object *CreateDeploymentResponseBody
}

func (o *CreateDeploymentResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *CreateDeploymentResponse) GetObject() *CreateDeploymentResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}

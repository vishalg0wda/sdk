// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

// Connection - Information for the SAML Single Sign-On configuration.
type Connection struct {
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
	// Current status of the connection.
	Status string `json:"status"`
	// Current state of the connection.
	State string `json:"state"`
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt float64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *float64 `json:"lastReceivedWebhookEvent,omitempty"`
}

func (o *Connection) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *Connection) GetStatus() string {
	if o == nil {
		return ""
	}
	return o.Status
}

func (o *Connection) GetState() string {
	if o == nil {
		return ""
	}
	return o.State
}

func (o *Connection) GetConnectedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConnectedAt
}

func (o *Connection) GetLastReceivedWebhookEvent() *float64 {
	if o == nil {
		return nil
	}
	return o.LastReceivedWebhookEvent
}

// Directory - Information for the Directory Sync configuration.
type Directory struct {
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
	// Current state of the connection.
	State string `json:"state"`
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt float64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *float64 `json:"lastReceivedWebhookEvent,omitempty"`
}

func (o *Directory) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *Directory) GetState() string {
	if o == nil {
		return ""
	}
	return o.State
}

func (o *Directory) GetConnectedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConnectedAt
}

func (o *Directory) GetLastReceivedWebhookEvent() *float64 {
	if o == nil {
		return nil
	}
	return o.LastReceivedWebhookEvent
}

// Saml - When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
type Saml struct {
	// Information for the SAML Single Sign-On configuration.
	Connection *Connection `json:"connection,omitempty"`
	// Information for the Directory Sync configuration.
	Directory *Directory `json:"directory,omitempty"`
	// When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.
	Enforced bool `json:"enforced"`
}

func (o *Saml) GetConnection() *Connection {
	if o == nil {
		return nil
	}
	return o.Connection
}

func (o *Saml) GetDirectory() *Directory {
	if o == nil {
		return nil
	}
	return o.Directory
}

func (o *Saml) GetEnforced() bool {
	if o == nil {
		return false
	}
	return o.Enforced
}

type Entitlements struct {
	Entitlement string `json:"entitlement"`
}

func (o *Entitlements) GetEntitlement() string {
	if o == nil {
		return ""
	}
	return o.Entitlement
}

type Role string

const (
	RoleOwner       Role = "OWNER"
	RoleMember      Role = "MEMBER"
	RoleDeveloper   Role = "DEVELOPER"
	RoleSecurity    Role = "SECURITY"
	RoleBilling     Role = "BILLING"
	RoleViewer      Role = "VIEWER"
	RoleContributor Role = "CONTRIBUTOR"
)

func (e Role) ToPointer() *Role {
	return &e
}
func (e *Role) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "CONTRIBUTOR":
		*e = Role(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Role: %v", v)
	}
}

type TeamRoles string

const (
	TeamRolesOwner       TeamRoles = "OWNER"
	TeamRolesMember      TeamRoles = "MEMBER"
	TeamRolesDeveloper   TeamRoles = "DEVELOPER"
	TeamRolesSecurity    TeamRoles = "SECURITY"
	TeamRolesBilling     TeamRoles = "BILLING"
	TeamRolesViewer      TeamRoles = "VIEWER"
	TeamRolesContributor TeamRoles = "CONTRIBUTOR"
)

func (e TeamRoles) ToPointer() *TeamRoles {
	return &e
}
func (e *TeamRoles) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "CONTRIBUTOR":
		*e = TeamRoles(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamRoles: %v", v)
	}
}

type TeamPermissions string

const (
	TeamPermissionsCreateProject            TeamPermissions = "CreateProject"
	TeamPermissionsFullProductionDeployment TeamPermissions = "FullProductionDeployment"
	TeamPermissionsUsageViewer              TeamPermissions = "UsageViewer"
)

func (e TeamPermissions) ToPointer() *TeamPermissions {
	return &e
}
func (e *TeamPermissions) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CreateProject":
		fallthrough
	case "FullProductionDeployment":
		fallthrough
	case "UsageViewer":
		*e = TeamPermissions(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamPermissions: %v", v)
	}
}

type Origin string

const (
	OriginLink              Origin = "link"
	OriginSaml              Origin = "saml"
	OriginGithub            Origin = "github"
	OriginGitlab            Origin = "gitlab"
	OriginBitbucket         Origin = "bitbucket"
	OriginMail              Origin = "mail"
	OriginImport            Origin = "import"
	OriginTeams             Origin = "teams"
	OriginDsync             Origin = "dsync"
	OriginFeedback          Origin = "feedback"
	OriginOrganizationTeams Origin = "organization-teams"
)

func (e Origin) ToPointer() *Origin {
	return &e
}
func (e *Origin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "link":
		fallthrough
	case "saml":
		fallthrough
	case "github":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		fallthrough
	case "mail":
		fallthrough
	case "import":
		fallthrough
	case "teams":
		fallthrough
	case "dsync":
		fallthrough
	case "feedback":
		fallthrough
	case "organization-teams":
		*e = Origin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Origin: %v", v)
	}
}

type GitUserIDType string

const (
	GitUserIDTypeStr    GitUserIDType = "str"
	GitUserIDTypeNumber GitUserIDType = "number"
)

type GitUserID struct {
	Str    *string
	Number *float64

	Type GitUserIDType
}

func CreateGitUserIDStr(str string) GitUserID {
	typ := GitUserIDTypeStr

	return GitUserID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGitUserIDNumber(number float64) GitUserID {
	typ := GitUserIDTypeNumber

	return GitUserID{
		Number: &number,
		Type:   typ,
	}
}

func (u *GitUserID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = GitUserIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = GitUserIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitUserID", string(data))
}

func (u GitUserID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GitUserID: all fields are null")
}

type JoinedFrom struct {
	Origin           Origin     `json:"origin"`
	CommitID         *string    `json:"commitId,omitempty"`
	RepoID           *string    `json:"repoId,omitempty"`
	RepoPath         *string    `json:"repoPath,omitempty"`
	GitUserID        *GitUserID `json:"gitUserId,omitempty"`
	GitUserLogin     *string    `json:"gitUserLogin,omitempty"`
	SsoUserID        *string    `json:"ssoUserId,omitempty"`
	SsoConnectedAt   *float64   `json:"ssoConnectedAt,omitempty"`
	IdpUserID        *string    `json:"idpUserId,omitempty"`
	DsyncUserID      *string    `json:"dsyncUserId,omitempty"`
	DsyncConnectedAt *float64   `json:"dsyncConnectedAt,omitempty"`
}

func (o *JoinedFrom) GetOrigin() Origin {
	if o == nil {
		return Origin("")
	}
	return o.Origin
}

func (o *JoinedFrom) GetCommitID() *string {
	if o == nil {
		return nil
	}
	return o.CommitID
}

func (o *JoinedFrom) GetRepoID() *string {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *JoinedFrom) GetRepoPath() *string {
	if o == nil {
		return nil
	}
	return o.RepoPath
}

func (o *JoinedFrom) GetGitUserID() *GitUserID {
	if o == nil {
		return nil
	}
	return o.GitUserID
}

func (o *JoinedFrom) GetGitUserLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitUserLogin
}

func (o *JoinedFrom) GetSsoUserID() *string {
	if o == nil {
		return nil
	}
	return o.SsoUserID
}

func (o *JoinedFrom) GetSsoConnectedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.SsoConnectedAt
}

func (o *JoinedFrom) GetIdpUserID() *string {
	if o == nil {
		return nil
	}
	return o.IdpUserID
}

func (o *JoinedFrom) GetDsyncUserID() *string {
	if o == nil {
		return nil
	}
	return o.DsyncUserID
}

func (o *JoinedFrom) GetDsyncConnectedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DsyncConnectedAt
}

// Membership - The membership of the authenticated User in relation to the Team.
type Membership struct {
	UID               *string           `json:"uid,omitempty"`
	Entitlements      []Entitlements    `json:"entitlements,omitempty"`
	Confirmed         bool              `json:"confirmed"`
	ConfirmedAt       float64           `json:"confirmedAt"`
	AccessRequestedAt *float64          `json:"accessRequestedAt,omitempty"`
	Role              Role              `json:"role"`
	TeamRoles         []TeamRoles       `json:"teamRoles,omitempty"`
	TeamPermissions   []TeamPermissions `json:"teamPermissions,omitempty"`
	TeamID            *string           `json:"teamId,omitempty"`
	CreatedAt         float64           `json:"createdAt"`
	Created           float64           `json:"created"`
	JoinedFrom        *JoinedFrom       `json:"joinedFrom,omitempty"`
}

func (o *Membership) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *Membership) GetEntitlements() []Entitlements {
	if o == nil {
		return nil
	}
	return o.Entitlements
}

func (o *Membership) GetConfirmed() bool {
	if o == nil {
		return false
	}
	return o.Confirmed
}

func (o *Membership) GetConfirmedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConfirmedAt
}

func (o *Membership) GetAccessRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessRequestedAt
}

func (o *Membership) GetRole() Role {
	if o == nil {
		return Role("")
	}
	return o.Role
}

func (o *Membership) GetTeamRoles() []TeamRoles {
	if o == nil {
		return nil
	}
	return o.TeamRoles
}

func (o *Membership) GetTeamPermissions() []TeamPermissions {
	if o == nil {
		return nil
	}
	return o.TeamPermissions
}

func (o *Membership) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *Membership) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *Membership) GetCreated() float64 {
	if o == nil {
		return 0.0
	}
	return o.Created
}

func (o *Membership) GetJoinedFrom() *JoinedFrom {
	if o == nil {
		return nil
	}
	return o.JoinedFrom
}

// TeamLimited - A limited form of data representing a Team, due to the authentication token missing privileges to read the full Team data.
type TeamLimited struct {
	// Property indicating that this Team data contains only limited information, due to the authentication token missing privileges to read the full Team data. Re-login with the Team's configured SAML Single Sign-On provider in order to upgrade the authentication token with the necessary privileges.
	Limited bool `json:"limited"`
	// When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
	Saml *Saml `json:"saml,omitempty"`
	// The Team's unique identifier.
	ID string `json:"id"`
	// The Team's slug, which is unique across the Vercel platform.
	Slug string `json:"slug"`
	// Name associated with the Team account, or `null` if none has been provided.
	Name *string `json:"name"`
	// The ID of the file used as avatar for this Team.
	Avatar *string `json:"avatar"`
	// The membership of the authenticated User in relation to the Team.
	Membership Membership `json:"membership"`
	// Will remain undocumented. Remove in v3 API.
	Created string `json:"created"`
	// UNIX timestamp (in milliseconds) when the Team was created.
	CreatedAt float64 `json:"createdAt"`
}

func (o *TeamLimited) GetLimited() bool {
	if o == nil {
		return false
	}
	return o.Limited
}

func (o *TeamLimited) GetSaml() *Saml {
	if o == nil {
		return nil
	}
	return o.Saml
}

func (o *TeamLimited) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *TeamLimited) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *TeamLimited) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *TeamLimited) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

func (o *TeamLimited) GetMembership() Membership {
	if o == nil {
		return Membership{}
	}
	return o.Membership
}

func (o *TeamLimited) GetCreated() string {
	if o == nil {
		return ""
	}
	return o.Created
}

func (o *TeamLimited) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}
